<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HEXUKI - Strategic Number Placement Game</title>
    <!-- Google Fonts - moved outside CSS for better GitHub Pages compatibility -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1d29 0%, #2d3249 50%, #1e2139 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 10px 0 0 0;
            margin: 0;
        }

        .game-container {
            background: linear-gradient(to right, 
                rgba(255, 240, 240, 0.98) 0%, 
                rgba(255, 255, 255, 0.98) 50%, 
                rgba(240, 248, 255, 0.98) 100%);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 8px;
            max-width: 960px;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 16px 48px rgba(0, 0, 0, 0.3);
            transform: scale(0.75);
            transform-origin: top;
            margin-top: 0;
        }


        .game-header {
            text-align: center;
            margin-bottom: 2px;
            position: relative;
            z-index: 10;
            margin-top: 0;
        }

        .game-header h1 {
            color: #1a202c;
            font-size: 1.9em;
            font-weight: 700;
            margin-bottom: 2px;
            margin-top: 0;
            letter-spacing: -0.025em;
        }

        .game-layout {
            display: flex;
            justify-content: center;
            align-items: start;
            width: 100%;
            max-width: 1400px;
            position: relative;
            margin: 0 auto;
            margin-top: -5px;
        }

        
        .game-board-container {
            position: relative;
            z-index: 1;
        }

        .player-panel {
            border-radius: 16px;
            padding: 25px;
            box-shadow: 0 6px 24px rgba(0,0,0,0.12);
            border: 1px solid rgba(0,0,0,0.08);
            position: absolute;
            overflow: visible;
            z-index: 10;
            width: 380px;
            height: 550px;
            top: 0;
        }
        
        .player-panel.player1 {
            left: -230px;
        }
        
        .player-panel.player2 {
            right: -230px;
        }


        .player-panel.player1 {
            background: linear-gradient(145deg, #fdf6f6, #f8f9fa);
            z-index: 15;
        }

        .player-panel.player2 {
            background: linear-gradient(145deg, #f6f8fd, #f8f9fa);
            z-index: 10;
        }

        .player-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60%;
            height: 4px;
            background: linear-gradient(90deg, transparent, currentColor, transparent);
            border-radius: 0 0 2px 2px;
        }

        .player-panel.player1::before {
            color: #c0392b;
        }

        .player-panel.player2::before {
            color: #2980b9;
        }

        .player-panel h3 {
            margin-bottom: 18px;
            color: #333;
            font-size: 1.6em;
            font-weight: 700;
            text-align: center;
            position: relative;
            padding-bottom: 12px;
        }

        .player-panel.player1 h3 {
            color: #c0392b;
        }

        .player-panel.player2 h3 {
            color: #2980b9;
        }

        .player-panel h3::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 2px;
            background: currentColor;
            border-radius: 1px;
        }

        .player-panel.active {
            box-shadow: 0 10px 40px rgba(0,0,0,0.18);
            transform: scale(1.05);
            transition: all 0.3s ease;
            z-index: 20;
            border: 2px solid #27ae60;
            box-shadow: 0 10px 40px rgba(0,0,0,0.18), 0 0 0 1px rgba(39, 174, 96, 0.3);
        }

        .score {
            font-size: 2.1em;
            font-weight: bold;
            margin: 16px 0;
            text-align: center;
            padding: 14px;
            background: rgba(255,255,255,0.5);
            border-radius: 12px;
            border: 1px solid rgba(0,0,0,0.05);
        }

        .tiles-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px 10px;
            row-gap: 20px;
            margin-top: 20px;
            justify-items: center;
            align-items: center;
            padding: 20px;
            height: 320px;
            align-content: center;
            justify-content: center;
        }

        .tile {
            width: 118px;
            height: 104px;
            cursor: pointer;
            transition: all 0.3s ease;
            justify-self: center;
            align-self: center;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .tile-hex {
            width: 101px;
            height: 88px;
            fill: #ffd700;
            stroke: #ddd;
            stroke-width: 2;
            filter: drop-shadow(0 2px 8px rgba(0,0,0,0.15));
            transition: all 0.3s ease;
            vector-effect: non-scaling-stroke;
        }
        
        .tile-text {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 44px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            fill: #333;
        }

        .tile:hover:not(.used) {
            transform: scale(1.1);
        }
        
        .tile:hover:not(.used) .tile-hex {
            filter: drop-shadow(0 6px 20px rgba(0,0,0,0.25));
        }

        .tile.selected {
            transform: scale(1.1);
        }
        
        .tile.selected .tile-hex {
            fill: #ffffff;
            stroke: #007bff;
            stroke-width: 4;
            filter: drop-shadow(0 0 15px rgba(0, 123, 255, 0.6));
            animation: selectedGlow 2s ease-in-out infinite alternate;
            vector-effect: non-scaling-stroke;
        }
        
        .tile.selected .tile-text {
            fill: #007bff;
            font-weight: 700;
        }
        
        .player1 .tile.selected .tile-hex {
            stroke: #c0392b;
            filter: drop-shadow(0 0 15px rgba(192, 57, 43, 0.6));
            animation: selectedGlowRed 2s ease-in-out infinite alternate;
            vector-effect: non-scaling-stroke;
        }
        
        .player1 .tile.selected .tile-text {
            fill: #c0392b;
        }
        
        .player2 .tile.selected .tile-hex {
            stroke: #2980b9;
            filter: drop-shadow(0 0 15px rgba(41, 128, 185, 0.6));
            animation: selectedGlowBlue 2s ease-in-out infinite alternate;
            vector-effect: non-scaling-stroke;
        }
        
        .player2 .tile.selected .tile-text {
            fill: #2980b9;
        }
        
        @keyframes selectedGlow {
            0% { stroke: #007bff; filter: drop-shadow(0 0 15px rgba(0, 123, 255, 0.6)); }
            100% { stroke: #0056cc; filter: drop-shadow(0 0 25px rgba(0, 86, 204, 0.8)); }
        }
        
        @keyframes selectedGlowRed {
            0% { stroke: #c0392b; filter: drop-shadow(0 0 15px rgba(192, 57, 43, 0.6)); }
            100% { stroke: #a93226; filter: drop-shadow(0 0 25px rgba(169, 50, 38, 0.8)); }
        }
        
        @keyframes selectedGlowBlue {
            0% { stroke: #2980b9; filter: drop-shadow(0 0 15px rgba(41, 128, 185, 0.6)); }
            100% { stroke: #21618c; filter: drop-shadow(0 0 25px rgba(33, 97, 140, 0.8)); }
        }

        .tile.used {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .player1 .tile-text {
            fill: #c0392b;
        }

        .player2 .tile-text {
            fill: #2980b9;
        }

        /* Chain violation tiles styling */
        .player1 .tile.chain-violation .tile-text {
            fill: #8b0000; /* Darker red for Player 1 */
        }

        .player2 .tile.chain-violation .tile-text {
            fill: #003d6b; /* Darker blue for Player 2 */
        }

        .player1 .tile.chain-violation .tile-hex {
            stroke: #8b0000;
            opacity: 0.8;
        }

        .player2 .tile.chain-violation .tile-hex {
            stroke: #003d6b;
            opacity: 0.8;
        }

        /* X overlay on chain violation tiles */
        .tile-violation-x {
            pointer-events: none;
            opacity: 1 !important;
        }

        .tile-empty {
            width: 80px;
            height: 80px;
            border: 3px dashed #ddd;
            border-radius: 15px;
            background: transparent;
            opacity: 0.3;
        }

        .empty-tile-space {
            opacity: 0.3;
            pointer-events: none;
        }

        .empty-tile-hex {
            fill: transparent;
            stroke: #ddd;
            stroke-width: 2;
            stroke-dasharray: 5, 5;
        }

        .board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start;
            transform: translateY(-104px);
            gap: 0px;
        }

        #gameBoard {
            background: white;
            border-radius: 8px;
            padding: 8px;
            margin-bottom: -8px;
            transform: scale(0.85);
        }


        .hex {
            fill: #f8f9fa;
            stroke: #333;
            stroke-width: 1;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .hex:hover:not(.occupied):not(.has-ghost-preview) {
            fill: #e9ecef;
        }

        .hex.valid-move {
            fill: #e8f5e8;
        }

        .hex.invalid-move {
            fill: #fdf2f2;
        }

        .hex.chain-violation-hex {
            fill: #fceaea;
        }

        .hex.occupied {
            cursor: default;
        }

        .hex-text {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 80px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }

        .hex-text.player1 {
            fill: #c0392b;
        }

        .hex-text.player2 {
            fill: #2980b9;
        }

        /* Ensure placed tile text never gets animated */
        .hex.occupied .hex-text {
            animation: none !important;
            opacity: 1 !important;
        }

        /* SVG Tile placement animations */
        g.tile-placing {
            animation: svg-tile-drop 0.405s cubic-bezier(0.34, 1.56, 0.64, 1);
            transform-origin: center center;
        }

        g.tile-placing .hex-text {
            animation: svg-tile-drop-text 0.405s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        g.tile-flash polygon {
            animation: svg-tile-highlight 0.27s ease-out;
        }

        @keyframes svg-tile-drop {
            0% {
                transform: translate(0, -20px) scale(0.8);
                opacity: 0.7;
            }
            60% {
                transform: translate(0, 2px) scale(1.05);
                opacity: 1;
            }
            80% {
                transform: translate(0, -1px) scale(0.98);
            }
            100% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
        }

        @keyframes svg-tile-drop-text {
            0% {
                opacity: 0;
                font-size: 40px;
            }
            50% {
                opacity: 0.8;
                font-size: 96px;
            }
            100% {
                opacity: 1;
                font-size: 80px;
            }
        }

        @keyframes svg-tile-highlight {
            0% {
                filter: drop-shadow(0 0 0 rgba(255, 215, 0, 0)) brightness(1);
            }
            50% {
                filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.8)) brightness(1.3);
            }
            100% {
                filter: drop-shadow(0 0 0 rgba(255, 215, 0, 0)) brightness(1);
            }
        }

        .suggestion-text {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 80px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            opacity: 0.4;
            fill: #666;
            animation: suggestionPulse 2s infinite;
        }

        @keyframes suggestionPulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.7; }
        }

        .hex-label {
            font-size: 28px;
            fill: #999;
            text-anchor: middle;
            dominant-baseline: middle;
            pointer-events: none;
        }

        .scoring-line {
            stroke-width: 4;
            fill: none;
            opacity: 0.4;
            pointer-events: none;
            stroke-dasharray: 10,6;
        }

        .scoring-line.player1 {
            stroke: #e74c3c;
        }

        .scoring-line.player2 {
            stroke: #3498db;
        }

        .scoring-indicators {
            display: flex;
            justify-content: center;
            gap: 60px;
            margin: -40px 0 -30px 0;
            transform: translateY(-90px);
            position: relative;
            z-index: 15;
        }

        .scoring-direction {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .direction-line {
            width: 80px;
            height: 4px;
            border-radius: 2px;
        }

        .player1-direction {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            transform: rotate(30deg);
        }

        .player2-direction {
            background: linear-gradient(-45deg, #3498db, #2980b9);
            transform: rotate(-30deg);
        }

        .direction-label {
            font-weight: 600;
            color: #333;
            font-size: 16px;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.6; }
            100% { opacity: 1; }
        }

        .controls {
            margin-top: -35px;
            text-align: center;
            transform: translateY(0px);
        }

        .btn {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 29px;
            border-radius: 24px;
            font-size: 1.44em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0 9px;
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .btn:hover:not(:disabled) {
            background: #5a67d8;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        .btn:active:not(:disabled) {
            transform: translateY(0) scale(0.98);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            transition: all 0.1s ease;
        }
        
        /* Ripple effect on click */
        .btn::after {
            content: '';
            position: absolute;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s, opacity 0.6s;
            opacity: 0;
        }
        
        .btn:active:not(:disabled)::after {
            width: 300px;
            height: 300px;
            opacity: 0;
            transition: width 0.6s, height 0.6s, opacity 0.6s;
        }
        
        .btn:disabled {
            background: #9ca3af;
            color: #6b7280;
            cursor: not-allowed;
            opacity: 0.5;
        }


        
        #newGameBtn {
            transform: translateY(5px);
        }
        
        #newGameBtn:hover:not(:disabled) {
            transform: translateY(3px);
        }
        
        #newGameBtn:disabled {
            transform: translateY(5px);
        }

        /* Analysis Mode Styles */
        .analysis-mode-indicator {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10000;
            pointer-events: none;
        }

        .analysis-badge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 30px;
            border-radius: 50px;
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.4);
            text-align: center;
            animation: pulse 4s infinite;
            position: relative;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .analysis-icon {
            font-size: 1.5em;
            margin-right: 10px;
        }

        .analysis-text {
            font-size: 1.2em;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .analysis-hint {
            font-size: 0.9em;
            opacity: 0.9;
            margin-top: 5px;
        }

        .analysis-exit-btn {
            position: absolute;
            top: 8px;
            right: 12px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        .analysis-exit-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .game-container.analysis-mode {
            border: 3px solid #667eea;
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
        }


        .score.analysis-score {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 5px;
            border-radius: 8px;
        }

        .score.analysis-score::before {
            content: "Test ";
            font-size: 1em;
            opacity: 0.9;
            margin-right: 4px;
        }

        .turn-indicator {
            text-align: center;
            margin-bottom: 16px;
            font-size: 1em;
            color: #333;
            font-weight: 600;
            position: relative;
            z-index: 10;
        }

        .message {
            text-align: center;
            margin-top: 5px;
            font-size: 1.32em;
            min-height: 25px;
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(-10px);
            z-index: 1000;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .message:not(:empty) {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
        }

        .message.error {
            color: #e74c3c;
        }

        .message.success {
            color: #27ae60;
        }

        /* Winner animations */
        .player-panel.winner {
            border: 3px solid;
            border-image: linear-gradient(45deg, 
                #ff0000, #ff7f00, #ffff00, #00ff00, 
                #0000ff, #4b0082, #9400d3, #ff0000) 1;
            animation: rainbow-border 2s linear infinite, winner-glow 2s ease-in-out infinite alternate;
        }

        @keyframes rainbow-border {
            0% { border-image-source: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000); }
            25% { border-image-source: linear-gradient(45deg, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000, #ff7f00); }
            50% { border-image-source: linear-gradient(45deg, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000, #ff7f00, #ffff00); }
            75% { border-image-source: linear-gradient(45deg, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000, #ff7f00, #ffff00, #00ff00); }
            100% { border-image-source: linear-gradient(45deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3, #ff0000); }
        }

        @keyframes winner-glow {
            0% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.5); }
            100% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.8), 0 0 60px rgba(255, 215, 0, 0.3); }
        }

        /* Ghost tile preview - only animate ghost text, not real placed tiles */
        .hex-text.ghost-text {
            animation: ghost-pulse 1.5s ease-in-out infinite;
        }

        /* Invalid move X indicator */
        .invalid-x {
            animation: ghost-pulse 1.5s ease-in-out infinite;
        }

        /* Question mark for valid moves without selected tile */
        .question-mark {
            animation: ghost-pulse 1.5s ease-in-out infinite;
        }

        /* Quick tile selector popup */
        .quick-tile-selector {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #333;
            border-radius: 12px;
            padding: 6px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            z-index: 1002;
            display: none;
            backdrop-filter: blur(10px);
            max-width: none;
            width: auto;
            opacity: 0;
            transform: translateY(-10px) scale(0.9);
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        .quick-tile-selector.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        .quick-tile-selector .quick-tiles-grid {
            display: grid;
            gap: 2px;
        }

        .quick-tile-selector .quick-tile {
            width: 50px;
            height: 43px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .quick-tile-selector .quick-tile:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }

        .quick-tile-selector .quick-tile svg {
            width: 100%;
            height: 100%;
        }

        @keyframes ghost-pulse {
            0% { opacity: 0.2; }
            50% { opacity: 0.5; }
            100% { opacity: 0.2; }
        }

        /* Player panel active state with smooth transitions */
        .player-panel {
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .player-panel.active {
            transform: scale(1.02);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15), 0 0 30px rgba(76, 175, 80, 0.6);
            border-color: rgba(76, 175, 80, 0.9);
        }

        /* Tile removal animation */
        .tile-container.removing {
            animation: tile-remove 3s linear forwards;
            pointer-events: none;
            background: red !important;
            border: 5px solid yellow !important;
        }

        @keyframes tile-remove {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
                background: red !important;
            }
            50% {
                transform: scale(2) rotate(45deg);
                opacity: 0.5;
                background: blue !important;
            }
            100% {
                transform: scale(3) rotate(180deg);
                opacity: 0;
                background: green !important;
            }
        }

        /* Liquid gradient background */
        .liquid-gradient {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            overflow: hidden;
            background: #1a2f4b;
            filter: blur(80px);
        }
        
        .gradient-blob {
            position: absolute;
            width: 400px;
            height: 400px;
            border-radius: 50%;
            mix-blend-mode: multiply;
            filter: blur(100px);
            opacity: 0.15;
        }
        
        .blob1 {
            background: radial-gradient(circle at center, 
                rgba(40, 50, 80, 0.5) 0%, 
                rgba(30, 40, 60, 0.3) 40%, 
                transparent 70%);
            top: -20%;
            left: -10%;
            animation: blob-float1 25s infinite ease-in-out;
        }
        
        .blob2 {
            background: radial-gradient(circle at center, 
                rgba(30, 45, 70, 0.5) 0%, 
                rgba(25, 35, 55, 0.3) 40%, 
                transparent 70%);
            top: 50%;
            right: -15%;
            animation: blob-float2 30s infinite ease-in-out;
        }
        
        .blob3 {
            background: radial-gradient(circle at center, 
                rgba(25, 35, 60, 0.5) 0%, 
                rgba(20, 30, 50, 0.3) 40%, 
                transparent 70%);
            bottom: -20%;
            left: 20%;
            animation: blob-float3 35s infinite ease-in-out;
        }
        
        .blob4 {
            background: radial-gradient(circle at center, 
                rgba(35, 40, 75, 0.5) 0%, 
                rgba(25, 30, 55, 0.3) 40%, 
                transparent 70%);
            bottom: 20%;
            right: 10%;
            animation: blob-float4 28s infinite ease-in-out;
        }
        
        @keyframes blob-float1 {
            0%, 100% {
                transform: translate(0, 0) scale(1) rotate(0deg);
            }
            25% {
                transform: translate(100px, 50px) scale(1.1) rotate(90deg);
            }
            50% {
                transform: translate(50px, 100px) scale(0.9) rotate(180deg);
            }
            75% {
                transform: translate(-50px, 50px) scale(1.05) rotate(270deg);
            }
        }
        
        @keyframes blob-float2 {
            0%, 100% {
                transform: translate(0, 0) scale(1) rotate(0deg);
            }
            25% {
                transform: translate(-80px, -60px) scale(0.95) rotate(-90deg);
            }
            50% {
                transform: translate(-120px, 40px) scale(1.1) rotate(-180deg);
            }
            75% {
                transform: translate(-40px, -80px) scale(1) rotate(-270deg);
            }
        }
        
        @keyframes blob-float3 {
            0%, 100% {
                transform: translate(0, 0) scale(1) rotate(0deg);
            }
            25% {
                transform: translate(60px, -80px) scale(1.05) rotate(120deg);
            }
            50% {
                transform: translate(100px, -40px) scale(0.95) rotate(240deg);
            }
            75% {
                transform: translate(40px, -60px) scale(1.08) rotate(360deg);
            }
        }
        
        @keyframes blob-float4 {
            0%, 100% {
                transform: translate(0, 0) scale(1) rotate(0deg);
            }
            25% {
                transform: translate(-70px, 40px) scale(1.08) rotate(-120deg);
            }
            50% {
                transform: translate(-30px, 80px) scale(0.92) rotate(-240deg);
            }
            75% {
                transform: translate(-100px, 20px) scale(1.02) rotate(-360deg);
            }
        }
        
        /* Removed bee animations - replaced with honeycomb pattern */
        
        /* @keyframes bee-fly-top {
            0% {
                transform: translateX(0) translateY(0) scale(1) rotate(90deg);
            }
            10% {
                transform: translateX(calc(10vw)) translateY(20px) scale(1.1) rotate(100deg);
            }
            15% {
                transform: translateX(calc(15vw)) translateY(30px) scale(1) rotate(110deg);
            }
            20% {
                transform: translateX(calc(20vw)) translateY(20px) scale(0.9) rotate(80deg);
            }
            30% {
                transform: translateX(calc(30vw)) translateY(-10px) scale(1) rotate(70deg);
            }
            35% {
                transform: translateX(calc(35vw)) translateY(-20px) scale(1.1) rotate(80deg);
            }
            40% {
                transform: translateX(calc(40vw)) translateY(-10px) scale(1) rotate(90deg);
            }
            50% {
                transform: translateX(calc(50vw)) translateY(15px) scale(0.95) rotate(95deg);
            }
            60% {
                transform: translateX(calc(60vw)) translateY(25px) scale(1.05) rotate(105deg);
            }
            65% {
                transform: translateX(calc(65vw)) translateY(30px) scale(1) rotate(100deg);
            }
            70% {
                transform: translateX(calc(70vw)) translateY(20px) scale(0.9) rotate(85deg);
            }
            80% {
                transform: translateX(calc(80vw)) translateY(-15px) scale(1) rotate(75deg);
            }
            90% {
                transform: translateX(calc(90vw)) translateY(5px) scale(1.1) rotate(95deg);
            }
            100% {
                transform: translateX(calc(100vw + 160px)) translateY(0) scale(1) rotate(90deg);
            }
        }
        
        @keyframes bee-fly-bottom {
            0% {
                transform: translateX(0) translateY(0) scale(1) rotate(-90deg);
            }
            10% {
                transform: translateX(calc(-10vw)) translateY(-20px) scale(0.9) rotate(-100deg);
            }
            15% {
                transform: translateX(calc(-15vw)) translateY(-30px) scale(1) rotate(-110deg);
            }
            20% {
                transform: translateX(calc(-20vw)) translateY(-20px) scale(1.1) rotate(-80deg);
            }
            30% {
                transform: translateX(calc(-30vw)) translateY(10px) scale(1) rotate(-70deg);
            }
            35% {
                transform: translateX(calc(-35vw)) translateY(20px) scale(0.9) rotate(-80deg);
            }
            40% {
                transform: translateX(calc(-40vw)) translateY(10px) scale(1) rotate(-90deg);
            }
            50% {
                transform: translateX(calc(-50vw)) translateY(-15px) scale(1.05) rotate(-95deg);
            }
            60% {
                transform: translateX(calc(-60vw)) translateY(-25px) scale(0.95) rotate(-105deg);
            }
            65% {
                transform: translateX(calc(-65vw)) translateY(-30px) scale(1) rotate(-100deg);
            }
            70% {
                transform: translateX(calc(-70vw)) translateY(-20px) scale(1.1) rotate(-85deg);
            }
            80% {
                transform: translateX(calc(-80vw)) translateY(15px) scale(1) rotate(-75deg);
            }
            90% {
                transform: translateX(calc(-90vw)) translateY(-5px) scale(0.9) rotate(-95deg);
            }
            100% {
                transform: translateX(calc(-100vw - 160px)) translateY(0) scale(1) rotate(-90deg);
            }
        }
        
        @keyframes bee-fly-left {
            0% {
                transform: translateY(0) translateX(0) scale(1) rotate(180deg);
            }
            10% {
                transform: translateY(calc(10vh)) translateX(20px) scale(1.05) rotate(170deg);
            }
            15% {
                transform: translateY(calc(15vh)) translateX(30px) scale(1) rotate(160deg);
            }
            20% {
                transform: translateY(calc(20vh)) translateX(20px) scale(0.95) rotate(175deg);
            }
            30% {
                transform: translateY(calc(30vh)) translateX(-10px) scale(1) rotate(185deg);
            }
            35% {
                transform: translateY(calc(35vh)) translateX(-20px) scale(1.1) rotate(190deg);
            }
            40% {
                transform: translateY(calc(40vh)) translateX(-10px) scale(1) rotate(180deg);
            }
            50% {
                transform: translateY(calc(50vh)) translateX(15px) scale(0.9) rotate(175deg);
            }
            60% {
                transform: translateY(calc(60vh)) translateX(25px) scale(1) rotate(165deg);
            }
            65% {
                transform: translateY(calc(65vh)) translateX(30px) scale(1.05) rotate(170deg);
            }
            70% {
                transform: translateY(calc(70vh)) translateX(20px) scale(1) rotate(180deg);
            }
            80% {
                transform: translateY(calc(80vh)) translateX(-15px) scale(0.95) rotate(190deg);
            }
            90% {
                transform: translateY(calc(90vh)) translateX(5px) scale(1.1) rotate(175deg);
            }
            100% {
                transform: translateY(calc(100vh + 160px)) translateX(0) scale(1) rotate(180deg);
            }
        }
        
        @keyframes bee-fly-right {
            0% {
                transform: translateY(0) translateX(0) scale(1) rotate(0deg);
            }
            10% {
                transform: translateY(calc(-10vh)) translateX(-20px) scale(0.9) rotate(10deg);
            }
            15% {
                transform: translateY(calc(-15vh)) translateX(-30px) scale(1) rotate(20deg);
            }
            20% {
                transform: translateY(calc(-20vh)) translateX(-20px) scale(1.1) rotate(5deg);
            }
            30% {
                transform: translateY(calc(-30vh)) translateX(10px) scale(1) rotate(-5deg);
            }
            35% {
                transform: translateY(calc(-35vh)) translateX(20px) scale(0.95) rotate(-10deg);
            }
            40% {
                transform: translateY(calc(-40vh)) translateX(10px) scale(1) rotate(0deg);
            }
            50% {
                transform: translateY(calc(-50vh)) translateX(-15px) scale(1.05) rotate(5deg);
            }
            60% {
                transform: translateY(calc(-60vh)) translateX(-25px) scale(1) rotate(15deg);
            }
            65% {
                transform: translateY(calc(-65vh)) translateX(-30px) scale(0.9) rotate(10deg);
            }
            70% {
                transform: translateY(calc(-70vh)) translateX(-20px) scale(1) rotate(0deg);
            }
            80% {
                transform: translateY(calc(-80vh)) translateX(15px) scale(1.1) rotate(-10deg);
            }
            90% {
                transform: translateY(calc(-90vh)) translateX(-5px) scale(0.95) rotate(5deg);
            }
            100% {
                transform: translateY(calc(-100vh - 160px)) translateX(0) scale(1) rotate(0deg);
            }
        } */

        /* Chain highlighting */
        .chain-line {
            stroke-width: 4;
            fill: none;
            opacity: 0;
            pointer-events: none;
            stroke-dasharray: 8,4;
            filter: drop-shadow(0 0 8px currentColor);
            z-index: 1000;
        }
        
        .chain-line.player1 {
            stroke: #e74c3c;
        }
        
        .chain-line.player2 {
            stroke: #3498db;
        }
        
        .chain-line.flash {
            animation: chain-flash 1.5s ease-out;
        }
        
        @keyframes chain-flash {
            0% {
                opacity: 0;
                stroke-dashoffset: 0;
            }
            20% {
                opacity: 0.8;
                stroke-dashoffset: -12;
            }
            100% {
                opacity: 0;
                stroke-dashoffset: -50;
            }
        }

        /* Confetti animation */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #f0f;
            animation: confetti-fall 3s linear forwards;
            pointer-events: none;
            z-index: 1001;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-10px) rotateZ(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(400px) rotateZ(720deg);
                opacity: 0;
            }
        }

        .game-status {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            border-radius: 10px;
            font-weight: bold;
            font-size: 1.2em;
            text-transform: uppercase;
        }

        .game-status.winner {
            background: linear-gradient(145deg, #2ecc71, #27ae60);
            color: white;
        }

        .game-status.loser {
            background: linear-gradient(145deg, #95a5a6, #7f8c8d);
            color: white;
        }

        .game-status.tie {
            background: linear-gradient(145deg, #f39c12, #e67e22);
            color: white;
        }

        .tile-set-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .tile-set-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            max-width: 800px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            transform: scale(1.05);
        }

        .tile-set-content h2 {
            text-align: center;
            margin-bottom: 25px;
            color: #1a202c;
        }

        .tile-set-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .tile-set-option {
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
        }

        .tile-set-option:hover {
            border-color: #3182ce;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .tile-set-option:active {
            transform: translateY(0) scale(0.99);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.1s ease;
        }

        .tile-set-option.random-option {
            background: linear-gradient(145deg, #ffd700, #ffed4a);
            border-color: #f59e0b;
        }

        .tile-set-option.random-option:hover {
            border-color: #d97706;
            background: linear-gradient(145deg, #ffed4a, #fbbf24);
        }

        .tile-set-option h3 {
            margin: 0 0 10px 0;
            color: #2d3748;
            font-size: 1.2em;
        }

        .tile-set-preview {
            font-family: 'JetBrains Mono', monospace;
            font-size: 14px;
            color: #4a5568;
            background: #f7fafc;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            text-align: center;
        }

        .tile-set-option p {
            margin: 0;
            font-size: 14px;
            color: #718096;
            line-height: 1.4;
        }

        .tile-set-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .close-tile-set {
            background: #e2e8f0;
            color: #4a5568;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .close-tile-set:hover {
            background: #cbd5e0;
        }

        .draft-modal, .draft-selection-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .draft-content, .draft-selection-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            max-width: 900px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            transform: scale(1.05);
        }

        .draft-content h2, .draft-selection-content h2 {
            text-align: center;
            margin-bottom: 25px;
            color: #1a202c;
        }

        .draft-pool-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .draft-pool-option {
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            background: linear-gradient(145deg, #ffffff, #f8f9fa);
        }

        .draft-pool-option:hover {
            border-color: #3182ce;
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .draft-pool-option:active {
            transform: translateY(0) scale(0.99);
            box-shadow: 0 2px 8px rgba(0,0,0,0.08);
            transition: all 0.1s ease;
        }

        .draft-pool-option h3 {
            margin: 0 0 10px 0;
            color: #2d3748;
            font-size: 1.2em;
        }

        .pool-preview {
            font-family: 'JetBrains Mono', monospace;
            font-size: 12px;
            color: #4a5568;
            background: #f7fafc;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            text-align: center;
            word-break: break-all;
        }

        .draft-pool-option p {
            margin: 0;
            font-size: 14px;
            color: #718096;
            line-height: 1.4;
        }

        .draft-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
        }

        .close-draft {
            background: #e2e8f0;
            color: #4a5568;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .close-draft:hover {
            background: #cbd5e0;
        }

        .reroll-pool {
            background: #3182ce;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 12px;
        }

        .reroll-pool:hover {
            background: #2c5aa0;
        }

        .draft-turn-indicator {
            text-align: center;
            font-size: 1.3em;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 25px;
            padding: 12px;
            background: linear-gradient(145deg, #ffd700, #ffed4a);
            border-radius: 12px;
            border: 2px solid #f59e0b;
        }

        .draft-pool-container {
            margin-bottom: 25px;
        }

        .draft-pool-container h3 {
            margin-bottom: 15px;
            color: #2d3748;
            text-align: center;
        }

        .draft-pool {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(60px, 1fr));
            gap: 8px;
            justify-items: center;
            padding: 15px;
            background: #f7fafc;
            border-radius: 12px;
            border: 2px solid #e2e8f0;
            max-height: 200px;
            overflow-y: auto;
        }

        .draft-tile {
            width: 60px;
            height: 60px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .draft-tile:hover {
            transform: scale(1.1);
        }

        .draft-tile svg {
            width: 100%;
            height: 100%;
        }

        .draft-tile-hex {
            fill: #ffd700;
            stroke: #ddd;
            stroke-width: 2;
            filter: drop-shadow(0 2px 8px rgba(0,0,0,0.15));
            transition: all 0.3s ease;
            vector-effect: non-scaling-stroke;
        }

        .draft-tile:hover .draft-tile-hex {
            fill: #ffed4a;
            stroke: #3182ce;
            filter: drop-shadow(0 4px 12px rgba(49, 130, 206, 0.3));
        }

        .draft-tile-text {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 24px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            fill: #333;
        }

        .draft-players {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .draft-player h4 {
            text-align: center;
            margin-bottom: 10px;
            color: #2d3748;
        }

        .drafted-tiles {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(50px, 1fr));
            gap: 6px;
            justify-items: center;
            padding: 10px;
            background: #f7fafc;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            min-height: 80px;
        }

        .drafted-tile {
            width: 50px;
            height: 50px;
        }

        .drafted-tile svg {
            width: 100%;
            height: 100%;
        }

        .drafted-tile .draft-tile-hex {
            fill: #e2e8f0;
            stroke: #cbd5e0;
        }

        .drafted-tile .draft-tile-text {
            font-size: 20px;
        }

        .rules-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .rules-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            max-width: 1040px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: slideIn 0.5s ease;
            margin: 20px;
            transform: scale(1.17);
            position: relative;
        }

        .rules-content h2 {
            color: #333;
            font-size: 2.2em;
            margin-bottom: 20px;
            text-align: center;
        }

        .rules-content h3 {
            color: #555;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
        }

        .rules-content p, .rules-content li {
            color: #666;
            line-height: 1.6;
            margin-bottom: 12px;
        }

        .rules-content ul {
            margin-left: 20px;
            margin-bottom: 20px;
        }

        .close-rules {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1.1em;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 20px auto;
            display: block;
        }
        
        .rules-close-x {
            position: fixed;
            top: 50px;
            right: 50px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 50%;
            width: 45px;
            height: 45px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 1001;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }
        
        .rules-close-x:hover {
            background: #c0392b;
            transform: scale(1.1);
        }

        .close-rules:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .scoring-example {
            display: flex;
            gap: 30px;
            margin: 25px 0;
            align-items: flex-start;
            justify-content: center;
            flex-wrap: wrap;
        }

        .example-board {
            margin: 20px auto;
        }

        .example-hex {
            fill: #f8f9fa;
            stroke: #333;
            stroke-width: 1;
        }

        .example-hex.filled {
            fill: #ffd700;
        }

        .example-text {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 20px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
        }

        .example-text.red {
            fill: #c0392b;
        }

        .example-text.blue {
            fill: #2980b9;
        }

        .example-text.neutral {
            fill: #333;
        }

        .example-label {
            font-size: 16px;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
            fill: #666;
        }

        .score-breakdown {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }

        .chain-calc {
            margin: 8px 0;
            padding: 8px 12px;
            border-radius: 6px;
            font-family: monospace;
            font-size: 14px;
        }

        .chain-calc.red {
            background: #fdf6f6;
            border-left: 4px solid #c0392b;
        }

        .chain-calc.blue {
            background: #f6f8fd;
            border-left: 4px solid #2980b9;
        }

        .total-score {
            font-size: 18px;
            font-weight: bold;
            margin-top: 10px;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .total-score.red {
            background: #fdf6f6;
            color: #c0392b;
        }

        .total-score.blue {
            background: #f6f8fd;
            color: #2980b9;
        }

    </style>
</head>
<body>
    <!-- Mobile Redirect Script -->
    <script>
        // Mobile detection and redirect
        function isMobile() {
            // Check user agent for mobile devices
            const mobileRegex = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile|CriOS/i;
            const userAgent = navigator.userAgent;
            
            // Check if it's actually a mobile device (not just small window)
            const isMobileDevice = mobileRegex.test(userAgent);
            const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            const isSmallScreenMobile = window.innerWidth <= 768 && (isMobileDevice || isTouchDevice);
            
            // Only redirect if it's actually a mobile device, not just a narrow desktop window
            return isMobileDevice && (isSmallScreenMobile || isTouchDevice);
        }
        
        // Only redirect if this is a mobile device/screen
        if (isMobile()) {
            // Replace 'mobile-hexuki-sim.html' with your actual mobile file name/URL
            // For GitHub Pages, this would be something like:
            // window.location.href = 'https://yourusername.github.io/hexuki-mobile/';
            
            // Redirect to mobile GitHub Pages site:
            window.location.href = 'https://yourusername.github.io/hexuki-mobile/';
        }
    </script>

    <div class="game-container">
        <div class="game-header">
            <h1>HEXUKI</h1>
            <div class="turn-indicator" id="turnIndicator">Player 1's Turn</div>
            <div class="message" id="message"></div>
        </div>


        <div class="game-layout">
            <div class="game-board-container">
                <div class="player-panel player1" id="player1Panel">
                    <h3>Player 1 (Red)</h3>
                    <div class="score" id="player1Score">Score: 0</div>
                    <div class="tiles-container" id="player1Tiles"></div>
                    <div class="game-status" id="player1Status" style="display: none;"></div>
                </div>

                <div class="board-container">
                    <svg id="gameBoard" width="960" height="960" viewBox="0 0 960 960">
                    </svg>
                    <div class="scoring-indicators">
                        <div class="scoring-direction">
                            <div class="direction-line player1-direction"></div>
                            <span class="direction-label">Player 1 (Red) - Down Right</span>
                        </div>
                        <div class="scoring-direction">
                            <div class="direction-line player2-direction"></div>
                            <span class="direction-label">Player 2 (Blue) - Down Left</span>
                        </div>
                    </div>
                    <div class="controls">
                        <button class="btn" id="changeTileSetBtn" onclick="showTileSetModal()">Change Tile Set</button>
                        <button class="btn" id="draftModeBtn" onclick="showDraftModal()">Draft Mode</button>
                        <button class="btn" id="analysisModeBtn" onclick="game.toggleAnalysisMode()">Analysis Mode</button>
                        <button class="btn" id="exitAnalysisBtn" onclick="game.exitAnalysisMode()" style="display: none; background: #e74c3c; color: white;">Exit Analysis</button>
                        <button class="btn" onclick="game.undo()">Undo</button>
                        <button class="btn" onclick="showRules()">Rules</button>
                        <button class="btn" id="newGameBtn" onclick="game.reset()">Reset Game</button>
                        <div id="credits-section" style="text-align: center; margin-top: 20px; font-size: 28px; color: #666;">
                            Designed by Michael Pohling<br>
                            Programming help from Dave Williamson (Game Logic)<br>
                            and Claude Code (Interface)<br>
                            Design Contributions by Darren Tighe, Leo Gauthier, and Dave Williamson
                        </div>
                    </div>
                </div>

                <div class="player-panel player2" id="player2Panel">
                    <h3>Player 2 (Blue)</h3>
                    <div class="score" id="player2Score">Score: 0</div>
                    <div class="tiles-container" id="player2Tiles"></div>
                    <div class="game-status" id="player2Status" style="display: none;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Analysis Mode Indicator -->
    <div class="analysis-mode-indicator" id="analysisModeIndicator" style="display: none;">
        <div class="analysis-badge">
            <span class="analysis-text">ANALYSIS MODE ACTIVE</span>
            <div class="analysis-hint">Place any tiles to see potential scores</div>
            <button class="analysis-exit-btn" onclick="game.exitAnalysisMode()" title="Exit Analysis Mode">X</button>
        </div>

    </div>

    <!-- Credits Modal -->
    <div class="modal" id="creditsModal" style="display: none;">
        <div class="modal-content">
            <div class="modal-header">
                <h2>🎮 HiveMind Credits</h2>
                <button class="close-modal" onclick="hideCredits()">×</button>
            </div>
            <div class="modal-body" style="text-align: center; padding: 30px;">
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #c0392b; margin-bottom: 10px;">Original Game Design</h3>
                    <p style="font-size: 18px; font-weight: 600;">[Your Name]</p>
                </div>
                
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #2980b9; margin-bottom: 10px;">Digital Programming & Development</h3>
                    <p style="font-size: 18px; font-weight: 600;">[Programmer Name]</p>
                </div>
                
                <div style="margin-bottom: 25px;">
                    <h3 style="color: #667eea; margin-bottom: 10px;">Special Thanks</h3>
                    <p>Playtesters, feedback providers, and the board game community</p>
                </div>
                
                <div style="margin-top: 30px; font-size: 14px; color: #666;">
                    <p>© 2024 [Your Company/Name]. All rights reserved.</p>
                    <p>Contact: <a href="mailto:info@hivemindgame.com">info@hivemindgame.com</a></p>
                </div>
            </div>
        </div>
    </div>

    <div class="draft-modal" id="draftModal" style="display: none;">
        <div class="draft-content">
            <h2>Draft Mode - Choose Pool</h2>
            
            <div class="draft-pool-options">
                <div class="draft-pool-option" onclick="startDraft('balanced')">
                    <h3>Balanced Draft</h3>
                    <div class="pool-preview">2x each number: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]</div>
                    <p>Fair competition with duplicate values</p>
                </div>
                
                <div class="draft-pool-option" onclick="startDraft('random')">
                    <h3>Random Pool</h3>
                    <div class="pool-preview">18 completely random numbers (1-9)</div>
                    <p>Unpredictable draft with varying distributions</p>
                </div>
                
                <div class="draft-pool-option" onclick="startDraft('pyramid')">
                    <h3>Pyramid Pool</h3>
                    <div class="pool-preview">[1,1,1,2,2,2,3,3,3,4,4,5,5,6,6,7,8,9]</div>
                    <p>More low values, fewer high values to fight over</p>
                </div>
                
                <div class="draft-pool-option" onclick="startDraft('extremes')">
                    <h3>High Stakes</h3>
                    <div class="pool-preview">[1,1,1,1,1,1,2,3,4,5,7,8,8,9,9,9,9,9]</div>
                    <p>Mostly 1s and 9s - extreme risk/reward decisions</p>
                </div>
                
                <div class="draft-pool-option" onclick="startDraft('fibonacci')">
                    <h3>Fibonacci Draft</h3>
                    <div class="pool-preview">[1,1,1,1,1,2,2,2,3,3,5,5,5,8,8,8,8,8]</div>
                    <p>Mathematical sequence with strategic scarcity</p>
                </div>
                
                <div class="draft-pool-option" onclick="startDraft('middling')">
                    <h3>Middle Ground</h3>
                    <div class="pool-preview">[2,2,3,3,3,4,4,4,4,5,5,5,5,6,6,6,7,7]</div>
                    <p>No extremes - steady tactical gameplay</p>
                </div>
            </div>
            
            <div class="draft-buttons">
                <button class="close-draft" onclick="hideDraftModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="draft-selection-modal" id="draftSelectionModal" style="display: none;">
        <div class="draft-selection-content">
            <h2>Draft Mode</h2>
            <div class="draft-turn-indicator" id="draftTurnIndicator">Player 2's Pick (1/18)</div>
            
            <div class="draft-pool-container">
                <h3>Available Tiles:</h3>
                <div class="draft-pool" id="draftPool"></div>
            </div>
            
            <div class="draft-players">
                <div class="draft-player">
                    <h4>Player 1 Drafted:</h4>
                    <div class="drafted-tiles" id="player1Drafted"></div>
                </div>
                <div class="draft-player">
                    <h4>Player 2 Drafted:</h4>
                    <div class="drafted-tiles" id="player2Drafted"></div>
                </div>
            </div>
            
            <div class="draft-buttons">
                <button class="reroll-pool" id="rerollPoolButton" onclick="rerollDraftPool()" style="display: none;">Reroll Pool</button>
                <button class="close-draft" onclick="cancelDraft()">Cancel Draft</button>
            </div>
        </div>
    </div>

    <div class="tile-set-modal" id="tileSetModal" style="display: none;">
        <div class="tile-set-content">
            <h2>Choose Tile Set</h2>
            
            <div class="tile-set-options">
                <div class="tile-set-option" onclick="selectTileSet('classic')">
                    <h3>Classic</h3>
                    <div class="tile-set-preview">[1, 2, 3, 4, 5, 6, 7, 8, 9]</div>
                    <p>Traditional balanced set with all unique values</p>
                </div>
                
                <div class="tile-set-option" onclick="selectTileSet('pyramid')">
                    <h3>Pyramid Power</h3>
                    <div class="tile-set-preview">[1, 2, 2, 3, 3, 3, 4, 4, 5]</div>
                    <p>More low values, strategic scarcity of high tiles</p>
                </div>
                
                <div class="tile-set-option" onclick="selectTileSet('extreme')">
                    <h3>Risk & Reward</h3>
                    <div class="tile-set-preview">[1, 1, 1, 2, 2, 5, 7, 9, 9]</div>
                    <p>High-stakes with extreme values and tough choices</p>
                </div>
                
                <div class="tile-set-option" onclick="selectTileSet('midrange')">
                    <h3>Mid-Range Focus</h3>
                    <div class="tile-set-preview">[2, 3, 4, 4, 5, 5, 6, 6, 7]</div>
                    <p>Consistent middle values for steady scoring</p>
                </div>
                
                <div class="tile-set-option" onclick="selectTileSet('fibonacci')">
                    <h3>Fibonacci</h3>
                    <div class="tile-set-preview">[1, 1, 2, 3, 5, 5, 8, 8, 8]</div>
                    <p>Mathematical sequence creates unique dynamics</p>
                </div>
                
                <div class="tile-set-option" onclick="selectTileSet('binary')">
                    <h3>Binary Choice</h3>
                    <div class="tile-set-preview">[1, 1, 1, 1, 8, 8, 8, 8, 9]</div>
                    <p>Extreme contrast: go big or go small</p>
                </div>
                
                <div class="tile-set-option" onclick="selectTileSet('randomSame')">
                    <h3>Random Mirror</h3>
                    <div class="tile-set-preview">[?, ?, ?, ?, ?, ?, ?, ?, ?]</div>
                    <p>Both players get the same randomized tile set</p>
                </div>
                
                <div class="tile-set-option" onclick="selectTileSet('randomDifferent')">
                    <h3>Random Chaos</h3>
                    <div class="tile-set-preview">P1:[?, ?, ?] P2:[?, ?, ?]</div>
                    <p>Each player gets a different random tile set</p>
                </div>
            </div>
            
            <div class="tile-set-buttons">
                <button class="close-tile-set" onclick="hideTileSetModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="rules-modal" id="rulesModal">
        <button class="rules-close-x" onclick="hideRules()">×</button>
        <div class="rules-content">
            <h2>Rules</h2>
            
            <h3>Objective</h3>
            <p>Place numbered tiles on the hexagonal board to score more points than your opponent through diagonal chain multiplication.</p>
            
            <h3>Setup</h3>
            <ul>
                <li>Each player starts with 9 tiles with a number value.</li>
                <li>The center hex starts with a neutral "1".</li>
                <li>Player 1 places any tile on the board to start the game. Players alternate placing 1 tile until all tiles are placed.</li>
            </ul>
            
            <h3>Placement Rules</h3>
            <ul>
                <li><strong>Adjacent Rule:</strong> New tiles must be placed next to existing tiles.</li>
                <li><strong>Chain Length Rule:</strong> The longest chain can be at most 1 longer than the second longest chain.
                    <ul>
                        <li>A chain is any number of consecutive tiles in a straight line.</li>
                    </ul>
                </li>
            </ul>
            
            <h3>Scoring Example</h3>
            <p><strong>Player 1 (Red):</strong> 5 diagonal chains going down-right<br>
            <strong>Player 2 (Blue):</strong> 5 diagonal chains going down-left</p>
            
            <div class="scoring-example">
                <div>
                    <h4>Sample End Game:</h4>
                    <svg class="example-board" width="500" height="480" viewBox="0 0 500 480">
                        <!-- Hex 0 -->
                        <polygon class="example-hex filled" points="275,70 264,50 242,50 231,70 242,90 264,90" />
                        <text class="example-text blue" x="253" y="70">6</text>
                        
                        <!-- Hex 1 -->
                        <polygon class="example-hex filled" points="214,100 203,80 181,80 170,100 181,120 203,120" />
                        <text class="example-text red" x="192" y="100">4</text>
                        
                        <!-- Hex 2 -->
                        <polygon class="example-hex filled" points="336,100 325,80 303,80 292,100 303,120 325,120" />
                        <text class="example-text blue" x="314" y="100">8</text>
                        
                        <!-- Hex 3 -->
                        <polygon class="example-hex filled" points="153,130 142,110 120,110 109,130 120,150 142,150" />
                        <text class="example-text red" x="131" y="130">7</text>
                        
                        <!-- Hex 4 -->
                        <polygon class="example-hex filled" points="275,130 264,110 242,110 231,130 242,150 264,150" />
                        <text class="example-text red" x="253" y="130">1</text>
                        
                        <!-- Hex 5 -->
                        <polygon class="example-hex filled" points="397,130 386,110 364,110 353,130 364,150 386,150" />
                        <text class="example-text blue" x="375" y="130">9</text>
                        
                        <!-- Hex 6 -->
                        <polygon class="example-hex filled" points="214,160 203,140 181,140 170,160 181,180 203,180" />
                        <text class="example-text red" x="192" y="160">3</text>
                        
                        <!-- Hex 7 -->
                        <polygon class="example-hex filled" points="336,160 325,140 303,140 292,160 303,180 325,180" />
                        <text class="example-text blue" x="314" y="160">2</text>
                        
                        <!-- Hex 8 -->
                        <polygon class="example-hex filled" points="153,190 142,170 120,170 109,190 120,210 142,210" />
                        <text class="example-text red" x="131" y="190">9</text>
                        
                        <!-- Hex 9 - center -->
                        <polygon class="example-hex filled" points="275,190 264,170 242,170 231,190 242,210 264,210" />
                        <text class="example-text neutral" x="253" y="190">1</text>
                        
                        <!-- Hex 10 -->
                        <polygon class="example-hex filled" points="397,190 386,170 364,170 353,190 364,210 386,210" />
                        <text class="example-text blue" x="375" y="190">5</text>
                        
                        <!-- Hex 11 -->
                        <polygon class="example-hex filled" points="214,220 203,200 181,200 170,220 181,240 203,240" />
                        <text class="example-text blue" x="192" y="220">1</text>
                        
                        <!-- Hex 12 -->
                        <polygon class="example-hex filled" points="336,220 325,200 303,200 292,220 303,240 325,240" />
                        <text class="example-text blue" x="314" y="220">7</text>
                        
                        <!-- Hex 13 -->
                        <polygon class="example-hex filled" points="153,250 142,230 120,230 109,250 120,270 142,270" />
                        <text class="example-text red" x="131" y="250">8</text>
                        
                        <!-- Hex 14 -->
                        <polygon class="example-hex filled" points="275,250 264,230 242,230 231,250 242,270 264,270" />
                        <text class="example-text blue" x="253" y="250">3</text>
                        
                        <!-- Hex 15 -->
                        <polygon class="example-hex filled" points="397,250 386,230 364,230 353,250 364,270 386,270" />
                        <text class="example-text red" x="375" y="250">6</text>
                        
                        <!-- Hex 16 -->
                        <polygon class="example-hex filled" points="214,280 203,260 181,260 170,280 181,300 203,300" />
                        <text class="example-text blue" x="192" y="280">4</text>
                        
                        <!-- Hex 17 -->
                        <polygon class="example-hex filled" points="336,280 325,260 303,260 292,280 303,300 325,300" />
                        <text class="example-text red" x="314" y="280">2</text>
                        
                        <!-- Hex 18 -->
                        <polygon class="example-hex filled" points="275,310 264,290 242,290 231,310 242,330 264,330" />
                        <text class="example-text red" x="253" y="310">5</text>
                        
                        <!-- Player 1 (Red) scoring chains - DOWNRIGHT -->
                        <!-- Chain 1: 0-2-5 -->
                        <line x1="192" y1="35" x2="436" y2="150" stroke="#c0392b" stroke-width="3" opacity="0.4" />
                        
                        <!-- Chain 2: 1-4-7-10 -->
                        <line x1="131" y1="65" x2="436" y2="210" stroke="#c0392b" stroke-width="3" opacity="0.4" />
                        
                        <!-- Chain 3: 3-6-9-12-15 -->
                        <line x1="70" y1="95" x2="436" y2="270" stroke="#c0392b" stroke-width="3" opacity="0.4" />
                        
                        <!-- Chain 4: 8-11-14-17 -->
                        <line x1="70" y1="155" x2="375" y2="300" stroke="#c0392b" stroke-width="3" opacity="0.4" />
                        
                        <!-- Chain 5: 13-16-18 -->
                        <line x1="70" y1="215" x2="314" y2="330" stroke="#c0392b" stroke-width="3" opacity="0.4" />
                        
                        <!-- Player 2 (Blue) scoring chains - DOWNLEFT -->
                        <!-- Chain 1: 0-1-3 -->
                        <line x1="314" y1="35" x2="70" y2="150" stroke="#2980b9" stroke-width="3" opacity="0.4" />
                        
                        <!-- Chain 2: 2-4-6-8 -->
                        <line x1="375" y1="65" x2="70" y2="210" stroke="#2980b9" stroke-width="3" opacity="0.4" />
                        
                        <!-- Chain 3: 5-7-9-11-13 -->
                        <line x1="436" y1="95" x2="70" y2="270" stroke="#2980b9" stroke-width="3" opacity="0.4" />
                        
                        <!-- Chain 4: 12-14-16-10 -->
                        <line x1="395" y1="175" x2="130" y2="305" stroke="#2980b9" stroke-width="3" opacity="0.4" />
                        
                        <!-- Chain 5: 15-17-18 -->
                        <line x1="436" y1="215" x2="192" y2="330" stroke="#2980b9" stroke-width="3" opacity="0.4" />
                    </svg>
                </div>
                
                <div class="score-breakdown">
                    <h4>Player 1 (Red) DOWNRIGHT:</h4>
                    <div class="chain-calc red">Chain 1: 6 × 8 × 9 = 432</div>
                    <div class="chain-calc red">Chain 2: 4 × 1 × 2 × 5 = 40</div>
                    <div class="chain-calc red">Chain 3: 7 × 3 × 1 × 7 × 6 = 882</div>
                    <div class="chain-calc red">Chain 4: 9 × 1 × 3 × 2 = 54</div>
                    <div class="chain-calc red">Chain 5: 8 × 4 × 5 = 160</div>
                    <div class="total-score red">Player 1 Total: 1,568</div>
                    
                    <h4>Player 2 (Blue) DOWNLEFT:</h4>
                    <div class="chain-calc blue">Chain 1: 6 × 4 × 7 = 168</div>
                    <div class="chain-calc blue">Chain 2: 8 × 1 × 3 × 9 = 216</div>
                    <div class="chain-calc blue">Chain 3: 9 × 2 × 1 × 1 × 8 = 144</div>
                    <div class="chain-calc blue">Chain 4: 7 × 3 × 4 × 5 = 420</div>
                    <div class="chain-calc blue">Chain 5: 6 × 2 × 5 = 60</div>
                    <div class="total-score blue">Player 2 Total: 1,008</div>
                </div>
            </div>
            
            <h3>Scoring Rules:</h3>
            <ul>
                <li>Each chain multiplies all tile values along that diagonal.</li>
                <li>Add up all 5 chain products for your total score.</li>
                <li>Don't be annoying by mirroring your opponent's moves exactly. If a tie happens naturally then it is a fair draw.</li>
            </ul>
            
            <button class="close-rules" onclick="hideRules()">Got It!</button>
        </div>
    </div>

    <!-- Quick tile selector popup -->
    <div class="quick-tile-selector" id="quickTileSelector">
        <div class="quick-tiles-grid" id="quickTilesGrid"></div>
    </div>

    <!-- Liquid gradient background -->
    <div class="liquid-gradient">
        <div class="gradient-blob blob1"></div>
        <div class="gradient-blob blob2"></div>
        <div class="gradient-blob blob3"></div>
        <div class="gradient-blob blob4"></div>
    </div>

    <script>
        console.log('🚀 HEXUKI DEBUG VERSION LOADED - Tile removal animation debugging active');
        class HexBoard {
            constructor() {
                this.hexSize = 84;
                this.board = [];
                this.hexElements = {};
                this.initializeBoard();
                this.selectedTile = null;
                this.selectedTileIndex = null;
            }

            initializeBoard() {
                // Order 2 board layout - 19 hexagons with seamless positioning
                const hexWidth = this.hexSize * 2;
                const hexHeight = Math.sqrt(3) * this.hexSize;
                const centerX = 480;
                const centerY = 480;
                
                const positions = [
                    {id: 0, row: 0, col: 2, x: centerX, y: centerY - hexHeight * 2},
                    {id: 1, row: 1, col: 1, x: centerX - hexWidth * 0.75, y: centerY - hexHeight * 1.5},
                    {id: 2, row: 1, col: 3, x: centerX + hexWidth * 0.75, y: centerY - hexHeight * 1.5},
                    {id: 3, row: 2, col: 0, x: centerX - hexWidth * 1.5, y: centerY - hexHeight},
                    {id: 4, row: 2, col: 2, x: centerX, y: centerY - hexHeight},
                    {id: 5, row: 2, col: 4, x: centerX + hexWidth * 1.5, y: centerY - hexHeight},
                    {id: 6, row: 3, col: 1, x: centerX - hexWidth * 0.75, y: centerY - hexHeight * 0.5},
                    {id: 7, row: 3, col: 3, x: centerX + hexWidth * 0.75, y: centerY - hexHeight * 0.5},
                    {id: 8, row: 4, col: 0, x: centerX - hexWidth * 1.5, y: centerY},
                    {id: 9, row: 4, col: 2, x: centerX, y: centerY},
                    {id: 10, row: 4, col: 4, x: centerX + hexWidth * 1.5, y: centerY},
                    {id: 11, row: 5, col: 1, x: centerX - hexWidth * 0.75, y: centerY + hexHeight * 0.5},
                    {id: 12, row: 5, col: 3, x: centerX + hexWidth * 0.75, y: centerY + hexHeight * 0.5},
                    {id: 13, row: 6, col: 0, x: centerX - hexWidth * 1.5, y: centerY + hexHeight},
                    {id: 14, row: 6, col: 2, x: centerX, y: centerY + hexHeight},
                    {id: 15, row: 6, col: 4, x: centerX + hexWidth * 1.5, y: centerY + hexHeight},
                    {id: 16, row: 7, col: 1, x: centerX - hexWidth * 0.75, y: centerY + hexHeight * 1.5},
                    {id: 17, row: 7, col: 3, x: centerX + hexWidth * 0.75, y: centerY + hexHeight * 1.5},
                    {id: 18, row: 8, col: 2, x: centerX, y: centerY + hexHeight * 2}
                ];

                positions.forEach(pos => {
                    this.board.push({
                        id: pos.id,
                        row: pos.row,
                        col: pos.col,
                        x: pos.x,
                        y: pos.y,
                        value: null,
                        owner: null
                    });
                });

                // Set center tile (id: 9) with value 1
                this.board[9].value = 1;
                this.board[9].owner = 'neutral';
            }

            drawBoard(svg, suggestedMove = null, game = null) {
                svg.innerHTML = '';
                
                console.log('Drawing board, suggested move:', suggestedMove);

                // Get valid moves to highlight them
                const validMoves = game ? game.getValidMoves() : [];
                
                // Get all empty adjacent moves (valid + invalid)
                const allAdjacentMoves = [];
                if (game) {
                    this.board.forEach(hex => {
                        if (hex.value === null) {
                            const adjacentHexes = game.getAdjacentHexes(hex.id);
                            const hasAdjacentOccupied = adjacentHexes.some(id => 
                                this.board[id] && this.board[id].value !== null
                            );
                            if (hasAdjacentOccupied) {
                                allAdjacentMoves.push(hex.id);
                            }
                        }
                    });
                }

                // Draw hexagons (no more scoring lines on board)
                this.board.forEach(hex => {
                    const hexGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    
                    // Create hexagon path
                    const hexPath = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    const points = this.getHexPoints(hex.x, hex.y);
                    hexPath.setAttribute('points', points);
                    hexPath.setAttribute('class', 'hex');
                    hexPath.setAttribute('data-id', hex.id);
                    
                    if (hex.value !== null) {
                        hexPath.classList.add('occupied');
                        hexPath.style.fill = '#ffd700'; // Yellow background for all placed tiles
                    } else if (validMoves.includes(hex.id)) {
                        hexPath.classList.add('valid-move');
                    } else if (allAdjacentMoves.includes(hex.id)) {
                        // Check if this is a chain violation for darker styling
                        const isChainViolation = game && game.checkChainLengthConstraint && !game.checkChainLengthConstraint(hex.id);
                        if (isChainViolation) {
                            hexPath.classList.add('chain-violation-hex');
                        } else {
                            hexPath.classList.add('invalid-move');
                        }
                    }

                    hexGroup.appendChild(hexPath);
                    
                    // Add red X for invalid spots AFTER the hex path so it renders on top
                    // BUT NOT for chain length violations
                    if (allAdjacentMoves.includes(hex.id) && !validMoves.includes(hex.id)) {
                        // Check if this is a chain violation - if so, DON'T add X
                        const isChainViolation = game && game.checkChainLengthConstraint && !game.checkChainLengthConstraint(hex.id);
                        
                        if (!isChainViolation) {
                            const invalidX = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            invalidX.setAttribute('x', hex.x);
                            invalidX.setAttribute('y', hex.y);
                            invalidX.setAttribute('text-anchor', 'middle');
                            invalidX.setAttribute('dominant-baseline', 'central');
                            invalidX.setAttribute('font-family', 'Arial, sans-serif');
                            invalidX.setAttribute('font-size', '32');
                            invalidX.setAttribute('font-weight', 'bold');
                            invalidX.setAttribute('fill', '#d63031');
                            invalidX.setAttribute('opacity', '0.25');
                            invalidX.setAttribute('pointer-events', 'none');
                            invalidX.textContent = '✗';
                            hexGroup.appendChild(invalidX);
                        }
                    }

                    // Add value if exists (centered, no labels)
                    if (hex.value !== null) {
                        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        text.setAttribute('x', hex.x);
                        text.setAttribute('y', hex.y - 5);
                        let textClass = 'hex-text';
                        if (hex.owner === 'player1') {
                            textClass += ' player1';
                        } else if (hex.owner === 'player2') {
                            textClass += ' player2';
                        } else {
                            text.style.fill = '#333'; // neutral center tile
                        }
                        text.setAttribute('class', textClass);
                        text.textContent = hex.value;
                        hexGroup.appendChild(text);
                    }

                    // Add suggestion if this hex is suggested
                    if (suggestedMove && suggestedMove.hexId === hex.id && hex.value === null) {
                        console.log('Drawing suggestion for hex:', hex.id, 'value:', suggestedMove.tileValue);
                        const suggestionText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        suggestionText.setAttribute('x', hex.x);
                        suggestionText.setAttribute('y', hex.y - 5);
                        suggestionText.setAttribute('class', 'suggestion-text');
                        suggestionText.textContent = suggestedMove.tileValue;
                        hexGroup.appendChild(suggestionText);
                    }

                    svg.appendChild(hexGroup);
                    this.hexElements[hex.id] = hexPath;

                    // Add click handler
                    hexPath.addEventListener('click', (e) => this.handleHexClick(hex.id, e));
                    
                    // Add touch support for mobile
                    hexPath.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        this.showGhostPreview(hex.id, game);
                    });
                    
                    hexPath.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        this.hideGhostPreview(hex.id);
                        this.handleHexClick(hex.id, e);
                    });
                    
                    // Add ghost preview handlers
                    hexPath.addEventListener('mouseenter', () => this.showGhostPreview(hex.id, game));
                    hexPath.addEventListener('mouseleave', () => this.hideGhostPreview(hex.id));
                    
                    // Add drag and drop handlers
                    hexPath.addEventListener('dragover', (e) => this.handleDragOver(e));
                    hexPath.addEventListener('drop', (e) => this.handleDrop(e, hex.id));
                });
            }


            getHexPoints(cx, cy) {
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = cx + this.hexSize * Math.cos(angle);
                    const y = cy + this.hexSize * Math.sin(angle);
                    points.push(`${x},${y}`);
                }
                return points.join(' ');
            }

            showGhostPreview(hexId, game) {
                if (!game) {
                    return;
                }

                const hex = this.board[hexId];
                if (hex.value !== null) {
                    return; // Already occupied
                }

                // Find the hex element and prevent hover background change
                const hexPath = this.hexElements[hexId];
                const hexGroup = hexPath.parentNode;
                
                // Add class to prevent hover background change
                hexPath.classList.add('has-ghost-preview');

                if (game.selectedTile) {
                    // Has a tile selected - show ghost tile or red X
                    const isLegal = game.isMoveLegal(hexId);
                    
                    if (isLegal) {
                        // Show ghost tile for valid moves
                        const playerColor = game.currentPlayer === 1 ? '#dc3545' : '#007bff';
                        const existingText = hexGroup.querySelector('.ghost-text');
                        if (!existingText) {
                            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            text.setAttribute('class', 'hex-text ghost-text');
                            text.setAttribute('x', hex.x);
                            text.setAttribute('y', hex.y - 5);
                            text.setAttribute('fill', playerColor);
                            text.textContent = game.selectedTile;
                            hexGroup.appendChild(text);
                        }
                    } else {
                        // Show red X for invalid moves
                        const existingX = hexGroup.querySelector('.invalid-x');
                        if (!existingX) {
                            const invalidX = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            invalidX.setAttribute('class', 'invalid-x');
                            invalidX.setAttribute('x', hex.x);
                            invalidX.setAttribute('y', hex.y);
                            invalidX.setAttribute('text-anchor', 'middle');
                            invalidX.setAttribute('dominant-baseline', 'central');
                            invalidX.setAttribute('font-family', 'Arial, sans-serif');
                            invalidX.setAttribute('font-size', '72');
                            invalidX.setAttribute('font-weight', 'bold');
                            invalidX.setAttribute('fill', '#dc3545');
                            invalidX.setAttribute('pointer-events', 'none');
                            invalidX.textContent = '✕';
                            hexGroup.appendChild(invalidX);
                        }
                    }
                } else {
                    // No tile selected - show question mark or X based on validity
                    const validMoves = game.getValidMoves();
                    if (validMoves.includes(hexId)) {
                        // Show question mark on valid move spaces
                        const existingQ = hexGroup.querySelector('.question-mark');
                        if (!existingQ) {
                            const questionMark = document.createElementNS("http://www.w3.org/2000/svg", "text");
                            questionMark.setAttribute('class', 'question-mark');
                            questionMark.setAttribute('x', hex.x);
                            questionMark.setAttribute('y', hex.y - 5);
                            questionMark.setAttribute('text-anchor', 'middle');
                            questionMark.setAttribute('dominant-baseline', 'central');
                            questionMark.setAttribute('font-family', 'Inter, Arial, sans-serif');
                            questionMark.setAttribute('font-size', '80');
                            questionMark.setAttribute('font-weight', '600');
                            questionMark.setAttribute('fill', '#333');
                            questionMark.setAttribute('pointer-events', 'none');
                            questionMark.textContent = '?';
                            hexGroup.appendChild(questionMark);
                        }
                    } else {
                        // Show red X on invalid spaces (even without tile selected)
                        // But NOT for chain length violations
                        const hasAdjacentOccupied = game.getAdjacentHexes(hexId).some(adjId => 
                            game.board.board[adjId].value !== null
                        );
                        
                        if (hasAdjacentOccupied) {
                            // Has adjacent - show X for ALL invalid moves (including chain violations)
                            const existingX = hexGroup.querySelector('.invalid-x');
                            if (!existingX) {
                                const invalidX = document.createElementNS("http://www.w3.org/2000/svg", "text");
                                invalidX.setAttribute('class', 'invalid-x');
                                invalidX.setAttribute('x', hex.x);
                                invalidX.setAttribute('y', hex.y);
                                invalidX.setAttribute('text-anchor', 'middle');
                                invalidX.setAttribute('dominant-baseline', 'central');
                                invalidX.setAttribute('font-family', 'Arial, sans-serif');
                                invalidX.setAttribute('font-size', '72');
                                invalidX.setAttribute('font-weight', 'bold');
                                invalidX.setAttribute('fill', '#dc3545');
                                invalidX.setAttribute('pointer-events', 'none');
                                invalidX.textContent = '✕';
                                hexGroup.appendChild(invalidX);
                            }
                        } else {
                            // No adjacent tiles - show X for adjacency violation
                            const existingX = hexGroup.querySelector('.invalid-x');
                            if (!existingX) {
                                const invalidX = document.createElementNS("http://www.w3.org/2000/svg", "text");
                                invalidX.setAttribute('class', 'invalid-x');
                                invalidX.setAttribute('x', hex.x);
                                invalidX.setAttribute('y', hex.y);
                                invalidX.setAttribute('text-anchor', 'middle');
                                invalidX.setAttribute('dominant-baseline', 'central');
                                invalidX.setAttribute('font-family', 'Arial, sans-serif');
                                invalidX.setAttribute('font-size', '72');
                                invalidX.setAttribute('font-weight', 'bold');
                                invalidX.setAttribute('fill', '#dc3545');
                                invalidX.setAttribute('pointer-events', 'none');
                                invalidX.textContent = '✕';
                                hexGroup.appendChild(invalidX);
                            }
                        }
                    }
                }
            }

            hideGhostPreview(hexId) {
                const hexPath = this.hexElements[hexId];
                const hexGroup = hexPath.parentNode;
                
                // Remove class to re-enable hover background change
                hexPath.classList.remove('has-ghost-preview');
                
                // Remove ghost text
                const ghostText = hexGroup.querySelector('.ghost-text');
                if (ghostText) {
                    ghostText.remove();
                }

                // Remove invalid X
                const invalidX = hexGroup.querySelector('.invalid-x');
                if (invalidX) {
                    invalidX.remove();
                }

                // Remove question mark
                const questionMark = hexGroup.querySelector('.question-mark');
                if (questionMark) {
                    questionMark.remove();
                }
            }

            handleHexClick(hexId, event) {
                console.log('=== HEX CLICK DEBUG ===');
                console.log('Hex ID:', hexId);
                console.log('Hex already occupied:', this.board[hexId].value !== null);
                console.log('Selected Tile:', this.selectedTile);
                console.log('Game Selected Tile:', game.selectedTile);
                console.log('Game Selected Original Position:', game.selectedOriginalPosition);
                
                if (this.board[hexId].value !== null) {
                    console.log('Cell already occupied, showing error');
                    game.showMessage('That cell is already occupied', 'error');
                    return;
                }

                if (this.selectedTile === null) {
                    console.log('No tile selected, checking for valid moves');
                    // Check if this is a valid move space - show quick selector
                    const validMoves = game.getValidMoves();
                    console.log('Valid moves:', validMoves);
                    if (validMoves.includes(hexId)) {
                        console.log('Showing quick selector for valid move');
                        game.showQuickTileSelector(hexId, event);
                    } else {
                        console.log('Invalid move location');
                        
                        // Check if invalid due to chain length violation specifically
                        const hasAdjacentOccupied = game.getAdjacentHexes(hexId).some(adjId => 
                            game.board.board[adjId].value !== null
                        );
                        
                        if (hasAdjacentOccupied && !game.checkChainLengthConstraint(hexId)) {
                            game.showMessage('Invalid move! Chain Length Violation', 'error');
                        } else {
                            game.showMessage('Invalid move! Not Adjacent Tile', 'error');
                        }
                    }
                    return;
                }

                console.log('Making move - Hex:', hexId, 'Tile:', this.selectedTile);
                game.makeMove(hexId, this.selectedTile);
            }

            handleDragOver(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            }

            handleDrop(e, hexId) {
                e.preventDefault();
                
                try {
                    const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
                    console.log('Dropped on hex:', hexId, 'with tile:', dragData);
                    
                    // Ensure the correct tile index is selected for removal
                    if (dragData.index !== undefined) {
                        game.selectedTileIndex = dragData.index;
                        game.selectedOriginalPosition = dragData.index; // The index is the original position
                    }
                    
                    // Make the move with the dropped tile
                    console.log('Drag drop - making move with dragData.value:', dragData.value);
                    game.makeMove(hexId, dragData.value);
                } catch (error) {
                    console.error('Error handling drop:', error);
                }
            }

            setSelectedTile(value) {
                this.selectedTile = value;
            }

            clone() {
                const newBoard = new HexBoard();
                newBoard.board = this.board.map(hex => ({
                    id: hex.id,
                    row: hex.row,
                    col: hex.col,
                    x: hex.x,
                    y: hex.y,
                    value: hex.value,
                    owner: hex.owner
                }));
                newBoard.selectedTile = this.selectedTile;
                return newBoard;
            }

        }

        class Game {
            constructor() {
                this.board = new HexBoard();
                this.currentPlayer = 1;
                this.player1Tiles = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                this.player2Tiles = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                this.player1OriginalTiles = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                this.player2OriginalTiles = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                this.player1UsedPositions = new Set(); // Track which positions have been used
                this.player2UsedPositions = new Set(); // Track which positions have been used
                this.selectedTile = null;
                this.selectedTileIndex = null;
                this.selectedOriginalPosition = null; // Track the original position of selected tile
                this.suggestedMove = null;
                this.moveHistory = [];
                this.gameEnded = false;
                
                // Chain definitions for highlighting
                this.chainDefinitions = {
                    player1: [
                        [0, 2, 5],        // Chain 1: A→C→F  
                        [1, 4, 7, 10],    // Chain 2: B→E→H→K
                        [3, 6, 9, 12, 15], // Chain 3: D→G→J→M→P
                        [8, 11, 14, 17],  // Chain 4: I→L→O→R
                        [13, 16, 18]      // Chain 5: N→Q→S
                    ],
                    player2: [
                        [0, 1, 3],        // Chain 1: A→B→D
                        [2, 4, 6, 8],     // Chain 2: C→E→G→I
                        [5, 7, 9, 11, 13], // Chain 3: F→H→J→L→N
                        [12, 14, 16, 10], // Chain 4: M→O→Q→K
                        [15, 17, 18]      // Chain 5: P→R→S
                    ]
                };
                this.tileSets = {
                    classic: [1, 2, 3, 4, 5, 6, 7, 8, 9],
                    pyramid: [1, 2, 2, 3, 3, 3, 4, 4, 5],
                    extreme: [1, 1, 1, 2, 2, 5, 7, 9, 9],
                    midrange: [2, 3, 4, 4, 5, 5, 6, 6, 7],
                    fibonacci: [1, 1, 2, 3, 5, 5, 8, 8, 8],
                    binary: [1, 1, 1, 1, 8, 8, 8, 8, 9]
                };
                this.draftPools = {
                    balanced: [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9],
                    pyramid: [1,1,1,2,2,2,3,3,3,4,4,5,5,6,6,7,8,9],
                    extremes: [1,1,1,1,1,1,2,3,4,5,7,8,8,9,9,9,9,9],
                    fibonacci: [1,1,1,1,1,2,2,2,3,3,5,5,5,8,8,8,8,8],
                    middling: [2,2,3,3,3,4,4,4,4,5,5,5,5,6,6,6,7,7]
                };
                
                // Analysis mode properties
                this.isAnalysisMode = false;
                this.preAnalysisState = null;
                this.analysisMoveHistory = []; // Separate move history for analysis mode
                this.isDrafting = false;
                this.draftPool = [];
                this.draftTurn = 2; // Player 2 starts
                this.draftCount = 0;
                this.init();
            }

            init() {
                this.board.drawBoard(document.getElementById('gameBoard'), this.suggestedMove, this);
                this.updateTileDisplay();
                this.updateScores();
                this.updateTurnIndicator();
                this.updateTileSetButtonState();
            }

            updateTileSetButtonState() {
                const tileSetButton = document.getElementById('changeTileSetBtn');
                const draftButton = document.getElementById('draftModeBtn');
                const canChangeTileSet = this.moveHistory.length === 0 && !this.isDrafting;
                
                tileSetButton.disabled = !canChangeTileSet;
                tileSetButton.style.opacity = canChangeTileSet ? '1' : '0.5';
                tileSetButton.style.cursor = canChangeTileSet ? 'pointer' : 'not-allowed';
                
                draftButton.disabled = !canChangeTileSet;
                draftButton.style.opacity = canChangeTileSet ? '1' : '0.5';
                draftButton.style.cursor = canChangeTileSet ? 'pointer' : 'not-allowed';
                
                this.updateResetButtonState();
            }
            
            updateResetButtonState() {
                const resetButton = document.getElementById('newGameBtn');
                const canReset = this.moveHistory.length > 0;
                
                resetButton.disabled = !canReset;
                resetButton.style.opacity = canReset ? '1' : '0.5';
                resetButton.style.cursor = canReset ? 'pointer' : 'not-allowed';
            }

            changeTileSet(setName) {
                if (this.moveHistory.length > 0) {
                    this.showMessage('Cannot change tile set after moves have been made!', 'error');
                    return;
                }

                // Clear the reset state so user can't undo previous reset after changing tile set
                this.preResetState = null;

                // Clear used positions when changing tile sets
                this.player1UsedPositions = new Set();
                this.player2UsedPositions = new Set();

                if (setName === 'randomSame') {
                    // Generate one random tile set for both players
                    const randomSet = this.generateRandomTileSet();
                    this.player1Tiles = [...randomSet];
                    this.player2Tiles = [...randomSet];
                    this.player1OriginalTiles = [...randomSet];
                    this.player2OriginalTiles = [...randomSet];
                    this.showMessage('Same random tile set generated for both players!', 'success');
                } else if (setName === 'randomDifferent') {
                    // Generate different random tile sets for each player
                    this.player1Tiles = this.generateRandomTileSet();
                    this.player2Tiles = this.generateRandomTileSet();
                    this.player1OriginalTiles = [...this.player1Tiles];
                    this.player2OriginalTiles = [...this.player2Tiles];
                    this.showMessage('Different random tile sets generated for each player!', 'success');
                } else if (this.tileSets[setName]) {
                    // Use predefined tile set - each player gets their own copy
                    this.player1Tiles = [...this.tileSets[setName]];
                    this.player2Tiles = [...this.tileSets[setName]];
                    this.player1OriginalTiles = [...this.tileSets[setName]];
                    this.player2OriginalTiles = [...this.tileSets[setName]];
                    this.showMessage(`Tile set changed to: ${setName.charAt(0).toUpperCase() + setName.slice(1)}`, 'success');
                }

                this.updateTileDisplay();
                this.updateScores();
            }

            generateRandomTileSet() {
                const tiles = [];
                for (let i = 0; i < 9; i++) {
                    tiles.push(Math.floor(Math.random() * 9) + 1);
                }
                return tiles.sort((a, b) => a - b);
            }

            startDraft(poolType) {
                if (this.moveHistory.length > 0) {
                    this.showMessage('Cannot start draft after moves have been made!', 'error');
                    return;
                }

                this.isDrafting = true;
                this.draftTurn = 2; // Player 2 picks first
                this.draftCount = 0;
                this.draftPoolType = poolType; // Store pool type for reroll functionality
                
                // Initialize draft pool
                if (poolType === 'random') {
                    this.draftPool = [];
                    for (let i = 0; i < 18; i++) {
                        this.draftPool.push(Math.floor(Math.random() * 9) + 1);
                    }
                } else {
                    this.draftPool = [...this.draftPools[poolType]];
                }
                
                // Reset player tiles for draft
                this.player1Tiles = [];
                this.player2Tiles = [];
                this.player1OriginalTiles = [];
                this.player2OriginalTiles = [];
                this.player1UsedPositions = new Set();
                this.player2UsedPositions = new Set();
                
                this.updateDraftDisplay();
                document.getElementById('draftSelectionModal').style.display = 'flex';
                this.updateTileSetButtonState();
            }

            updateDraftDisplay() {
                // Update turn indicator
                const turnIndicator = document.getElementById('draftTurnIndicator');
                turnIndicator.textContent = `Player ${this.draftTurn}'s Pick (${this.draftCount + 1}/18)`;
                
                // Show/hide reroll button (only for random pools with no picks made)
                const rerollButton = document.getElementById('rerollPoolButton');
                if (this.draftPoolType === 'random' && this.draftCount === 0) {
                    rerollButton.style.display = 'inline-block';
                } else {
                    rerollButton.style.display = 'none';
                }
                
                // Update available pool - sort by value
                const poolContainer = document.getElementById('draftPool');
                poolContainer.innerHTML = '';
                const sortedIndices = this.draftPool
                    .map((value, index) => ({ value, index }))
                    .sort((a, b) => a.value - b.value);
                
                sortedIndices.forEach(({ value, index }) => {
                    const tile = this.createDraftTile(value, index);
                    poolContainer.appendChild(tile);
                });
                
                // Update drafted tiles
                this.updateDraftedTilesDisplay();
            }

            createDraftTile(value, index) {
                const tileContainer = document.createElement('div');
                tileContainer.className = 'draft-tile';
                tileContainer.onclick = () => this.selectDraftTile(value, index);
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 60 52');
                
                // Create hexagon
                const cx = 30;
                const cy = 26;
                const radius = 25;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    points.push(`${x.toFixed(1)},${y.toFixed(1)}`);
                }
                
                const hexagon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                hexagon.setAttribute('class', 'draft-tile-hex');
                hexagon.setAttribute('points', points.join(' '));
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('class', 'draft-tile-text');
                text.setAttribute('x', cx);
                text.setAttribute('y', cy);
                text.textContent = value;
                
                svg.appendChild(hexagon);
                svg.appendChild(text);
                tileContainer.appendChild(svg);
                
                return tileContainer;
            }

            selectDraftTile(value, index) {
                if (!this.isDrafting) return;
                
                // Remove tile from pool
                this.draftPool.splice(index, 1);
                
                // Add to current player's tiles
                if (this.draftTurn === 1) {
                    this.player1Tiles.push(value);
                    this.player1OriginalTiles.push(value);
                } else {
                    this.player2Tiles.push(value);
                    this.player2OriginalTiles.push(value);
                }
                
                this.draftCount++;
                
                // Check if draft is complete
                if (this.draftCount >= 18) {
                    this.completeDraft();
                    return;
                }
                
                // Switch turns
                this.draftTurn = this.draftTurn === 1 ? 2 : 1;
                this.updateDraftDisplay();
            }

            updateDraftedTilesDisplay() {
                const p1Container = document.getElementById('player1Drafted');
                const p2Container = document.getElementById('player2Drafted');
                
                p1Container.innerHTML = '';
                p2Container.innerHTML = '';
                
                // Sort drafted tiles by value before displaying
                const sortedP1Tiles = [...this.player1OriginalTiles].sort((a, b) => a - b);
                const sortedP2Tiles = [...this.player2OriginalTiles].sort((a, b) => a - b);
                
                sortedP1Tiles.forEach(value => {
                    const tile = this.createDraftedTile(value);
                    p1Container.appendChild(tile);
                });
                
                sortedP2Tiles.forEach(value => {
                    const tile = this.createDraftedTile(value);
                    p2Container.appendChild(tile);
                });
            }

            createDraftedTile(value) {
                const tileContainer = document.createElement('div');
                tileContainer.className = 'drafted-tile';
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 50 43');
                
                const cx = 25;
                const cy = 21.5;
                const radius = 20;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    points.push(`${x.toFixed(1)},${y.toFixed(1)}`);
                }
                
                const hexagon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                hexagon.setAttribute('class', 'draft-tile-hex');
                hexagon.setAttribute('points', points.join(' '));
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('class', 'draft-tile-text');
                text.setAttribute('x', cx);
                text.setAttribute('y', cy);
                text.textContent = value;
                
                svg.appendChild(hexagon);
                svg.appendChild(text);
                tileContainer.appendChild(svg);
                
                return tileContainer;
            }

            completeDraft() {
                // Sort tiles for display
                this.player1OriginalTiles.sort((a, b) => a - b);
                this.player2OriginalTiles.sort((a, b) => a - b);
                this.player1Tiles.sort((a, b) => a - b);
                this.player2Tiles.sort((a, b) => a - b);
                
                this.isDrafting = false;
                document.getElementById('draftSelectionModal').style.display = 'none';
                this.updateTileDisplay();
                this.updateScores();
                this.updateTileSetButtonState();
                this.showMessage('Draft completed! Game ready to begin.', 'success');
            }

            rerollDraftPool() {
                if (this.draftPoolType !== 'random' || this.draftCount > 0) {
                    return; // Only allow reroll for random pools with no picks made
                }
                
                // Generate new random pool
                this.draftPool = [];
                for (let i = 0; i < 18; i++) {
                    this.draftPool.push(Math.floor(Math.random() * 9) + 1);
                }
                
                this.updateDraftDisplay();
                this.showMessage('Pool rerolled!', '');
            }

            cancelDraft() {
                this.isDrafting = false;
                this.player1Tiles = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                this.player2Tiles = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                this.player1OriginalTiles = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                this.player2OriginalTiles = [1, 2, 3, 4, 5, 6, 7, 8, 9];
                document.getElementById('draftSelectionModal').style.display = 'none';
                this.updateTileDisplay();
                this.updateScores();
                this.updateTileSetButtonState();
                this.showMessage('Draft cancelled. Returned to classic tile set.', '');
            }

            updateTileDisplay() {
                
                // Player 1 tiles - display all original tiles with current status
                const p1Container = document.getElementById('player1Tiles');
                p1Container.innerHTML = '';
                
                this.player1OriginalTiles.forEach((tileValue, originalPosition) => {
                    // Check if this specific position has been used
                    const isUsed = this.player1UsedPositions.has(originalPosition);
                    
                    if (!isUsed) {
                        // Tile is still available at this position
                        const tile = this.createHexTile(tileValue, 1, originalPosition, true);
                        p1Container.appendChild(tile);
                    } else {
                        // Create empty space for used tile
                        const emptySpace = this.createEmptyTileSpace();
                        p1Container.appendChild(emptySpace);
                    }
                });

                // Player 2 tiles - display all original tiles with current status
                const p2Container = document.getElementById('player2Tiles');
                p2Container.innerHTML = '';
                
                this.player2OriginalTiles.forEach((tileValue, originalPosition) => {
                    // Check if this specific position has been used
                    const isUsed = this.player2UsedPositions.has(originalPosition);
                    
                    if (!isUsed) {
                        // Tile is still available at this position
                        const tile = this.createHexTile(tileValue, 2, originalPosition, true);
                        p2Container.appendChild(tile);
                    } else {
                        // Create empty space for used tile
                        const emptySpace = this.createEmptyTileSpace();
                        p2Container.appendChild(emptySpace);
                    }
                });
            }

            createHexTile(value, player, index, isAvailable = true) {
                const tileContainer = document.createElement('div');
                tileContainer.className = 'tile';
                
                // Add drag and drop attributes and unique identifier
                tileContainer.draggable = true;
                tileContainer.dataset.value = value;
                tileContainer.dataset.player = player;
                tileContainer.dataset.index = index;
                const tileId = `tile-p${player}-${index}`;
                tileContainer.id = tileId;
                
                // Create SVG hexagon (20% bigger than previous)
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '101');
                svg.setAttribute('height', '88');
                svg.setAttribute('viewBox', '0 0 101 88');
                
                // Generate proper hexagon points (50px radius, centered)
                const cx = 50.5;
                const cy = 44; // (88/2)
                const radius = 50;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    points.push(`${x.toFixed(1)},${y.toFixed(1)}`);
                }
                
                const hexagon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                hexagon.setAttribute('class', 'tile-hex');
                hexagon.setAttribute('points', points.join(' '));
                
                // Text element
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('class', 'tile-text');
                text.setAttribute('x', cx);
                text.setAttribute('y', cy);
                text.textContent = value;
                
                svg.appendChild(hexagon);
                svg.appendChild(text);
                
                // Check if this tile would cause chain length violations on ALL legal moves
                if (isAvailable && this.currentPlayer === player) {
                    const wouldCauseViolation = this.wouldTileCauseChainViolation(value);
                    console.log(`Tile ${value} for player ${player}: chain violation = ${wouldCauseViolation}`);
                    if (wouldCauseViolation) {
                        tileContainer.classList.add('chain-violation');
                        console.log(`Added chain-violation class to tile ${value}`);
                    }
                }
                
                tileContainer.appendChild(svg);
                
                // Click handler
                tileContainer.onclick = () => this.selectTile(player, value, index);
                
                // Drag handlers
                tileContainer.ondragstart = (e) => this.handleDragStart(e, player, value, index);
                
                // Add hover handlers for ALL chain violation tiles (regardless of selection state)
                const wouldCauseViolation = this.wouldTileCauseChainViolation(value);
                console.log(`Setting up hover for tile ${value}, violation=${wouldCauseViolation}, available=${isAvailable}, currentPlayer=${this.currentPlayer}, player=${player}`);
                if (wouldCauseViolation && isAvailable && this.currentPlayer === player) {
                    console.log(`Adding hover handlers to chain violation tile ${value}`);
                    tileContainer.onmouseenter = () => {
                        console.log('Hovering over chain violation tile:', value);
                        // Show X on hover ALWAYS for chain violation tiles
                        const existingX = svg.querySelector('.hover-violation-x');
                        if (!existingX) {
                            const hoverX = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            hoverX.setAttribute('class', 'hover-violation-x');
                            hoverX.setAttribute('x', cx);
                            hoverX.setAttribute('y', cy);
                            hoverX.setAttribute('text-anchor', 'middle');
                            hoverX.setAttribute('dominant-baseline', 'central');
                            hoverX.setAttribute('font-family', 'Arial, sans-serif');
                            hoverX.setAttribute('font-size', '60');
                            hoverX.setAttribute('font-weight', 'bold');
                            hoverX.setAttribute('fill', '#ff0000');
                            hoverX.setAttribute('opacity', '1');
                            hoverX.setAttribute('pointer-events', 'none');
                            hoverX.setAttribute('stroke', '#ffffff');
                            hoverX.setAttribute('stroke-width', '3');
                            hoverX.textContent = '✕';
                            svg.appendChild(hoverX);
                            console.log('Added hover X to chain violation tile');
                        }
                    };
                    
                    tileContainer.onmouseleave = () => {
                        console.log('Leaving chain violation tile:', value);
                        // Remove hover X
                        const hoverX = svg.querySelector('.hover-violation-x');
                        if (hoverX) {
                            hoverX.remove();
                            console.log('Removed hover X from chain violation tile');
                        }
                    };
                }
                
                // Apply current state styles
                // In both normal and analysis mode, use the same styling
                if (isAvailable && this.currentPlayer === player && this.selectedTileIndex === index && this.selectedTile === value) {
                    tileContainer.classList.add('selected');
                }
                if (!isAvailable || this.currentPlayer !== player) {
                    tileContainer.classList.add('used');
                }
                
                return tileContainer;
            }

            wouldTileCauseChainViolation(tileValue) {
                // Check if this tile would cause chain length violations on ALL possible legal moves
                const validHexes = this.board.board.filter(hex => 
                    hex.value === null && 
                    this.getAdjacentHexes(hex.id).some(adjId => this.board.board[adjId].value !== null)
                );
                
                // If there are no valid moves, this tile won't cause violations
                if (validHexes.length === 0) return false;
                
                // Check if ALL valid moves would cause chain length violations
                for (const hex of validHexes) {
                    if (this.checkChainLengthConstraint(hex.id)) {
                        // Found at least one legal move, so this tile can be used
                        return false;
                    }
                }
                
                // All valid moves would cause violations
                return true;
            }

            createEmptyTileSpace() {
                const emptyContainer = document.createElement('div');
                emptyContainer.className = 'tile empty-tile-space';
                
                // Create SVG with same dimensions but empty/transparent
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '101');
                svg.setAttribute('height', '88');
                svg.setAttribute('viewBox', '0 0 101 88');
                
                // Create transparent hexagon outline
                const cx = 50.5;
                const cy = 44;
                const radius = 50;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = cx + radius * Math.cos(angle);
                    const y = cy + radius * Math.sin(angle);
                    points.push(`${x.toFixed(1)},${y.toFixed(1)}`);
                }
                
                const hexagon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                hexagon.setAttribute('class', 'empty-tile-hex');
                hexagon.setAttribute('points', points.join(' '));
                
                svg.appendChild(hexagon);
                emptyContainer.appendChild(svg);
                
                return emptyContainer;
            }

            handleDragStart(e, player, value, index) {
                console.log('Drag start:', { player, value, index, currentPlayer: this.currentPlayer, isAnalysisMode: this.isAnalysisMode });
                
                // Both in normal and analysis mode, only allow dragging current player's tiles
                if (this.currentPlayer !== player) {
                    console.log('Drag prevented: not current player');
                    e.preventDefault();
                    return;
                }
                
                // Store drag data
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    player: player,
                    value: value,
                    index: index
                }));
                e.dataTransfer.effectAllowed = 'move';
                
                // Select the tile being dragged
                this.selectTile(player, value, index);
            }

            selectTile(player, value, originalPosition) {
                console.log('=== SELECT TILE DEBUG ===');
                console.log('Player:', player, 'Value:', value, 'Original Position:', originalPosition);
                console.log('Current Player:', this.currentPlayer);
                console.log('Analysis Mode:', this.isAnalysisMode);
                
                // Both in normal and analysis mode, only allow selecting current player's tiles
                if (player !== this.currentPlayer) {
                    console.log('Not player turn, showing error');
                    this.showMessage('It\'s not your turn!', 'error');
                    return;
                }

                // Check if this tile would cause chain violations
                if (this.wouldTileCauseChainViolation(value)) {
                    this.showMessage('Invalid move! Chain Length Violation', 'error');
                    return;
                }

                // Check if clicking on the same tile that's already selected - deselect it
                if (this.selectedTile === value && 
                    this.selectedOriginalPosition === originalPosition && 
                    this.selectedPlayer === player) {
                    // Deselect the tile
                    this.selectedTile = null;
                    this.selectedOriginalPosition = null;
                    this.selectedTileIndex = null;
                    this.selectedPlayer = null;
                    this.board.setSelectedTile(null);
                    this.clearAllGhostPreviews();
                    this.updateTileDisplay();
                    this.showMessage('Tile deselected', '');
                    return;
                }

                // Clear any existing ghost previews before selecting new tile
                this.clearAllGhostPreviews();

                this.selectedTile = value;
                this.selectedOriginalPosition = originalPosition; // Track the original position
                this.selectedTileIndex = originalPosition; // Keep for compatibility
                this.selectedPlayer = player; // Track which player's tile is selected
                this.board.setSelectedTile(value);
                this.updateTileDisplay();
                
                if (this.isAnalysisMode) {
                    this.showMessage(`Selected Player ${player}'s tile: ${value}`, 'success');
                } else {
                    this.showMessage(`Selected tile: ${value}. Click a hex to place it.`, 'success');
                }
            }

            clearAllGhostPreviews() {
                // Remove ghost preview from all hexes
                this.board.board.forEach(hex => {
                    this.board.hideGhostPreview(hex.id);
                });
            }

            clearGhostPreviewWithTransition(targetHexId) {
                // For the target hex, add a smooth transition effect
                const targetHexGroup = this.board.hexElements[targetHexId]?.parentNode;
                if (targetHexGroup) {
                    const ghostText = targetHexGroup.querySelector('.ghost-text');
                    if (ghostText) {
                        // Add transition effect to ghost before removing it
                        ghostText.style.transition = 'opacity 0.15s ease-out, transform 0.15s ease-out';
                        ghostText.style.opacity = '0';
                        ghostText.style.transform = 'scale(1.2)';
                        
                        setTimeout(() => {
                            if (ghostText.parentNode) {
                                ghostText.remove();
                            }
                        }, 150);
                    }
                }
                
                // Clear all other ghost previews normally
                this.board.board.forEach(hex => {
                    if (hex.id !== targetHexId) {
                        this.board.hideGhostPreview(hex.id);
                    }
                });
            }

            animateTilePlacement(hexId) {
                console.log('Animating tile placement for hex:', hexId);
                
                // Find the hex element that was just placed
                const hexElement = this.board.hexElements[hexId];
                if (!hexElement) {
                    console.log('No hex element found for:', hexId);
                    return;
                }
                
                const hexGroup = hexElement.parentNode;
                console.log('Found hex group:', hexGroup);
                
                // Remove any existing animation classes
                hexGroup.classList.remove('tile-placing', 'tile-flash');
                
                // Force reflow to ensure classes are removed
                hexGroup.offsetHeight;
                
                // Add placement animation
                hexGroup.classList.add('tile-placing');
                console.log('Added tile-placing class');
                
                // Add flash animation after a short delay
                setTimeout(() => {
                    hexGroup.classList.add('tile-flash');
                    console.log('Added tile-flash class');
                }, 203);
                
                // Clean up animation classes after animations complete
                setTimeout(() => {
                    hexGroup.classList.remove('tile-placing');
                    console.log('Removed tile-placing class');
                }, 405);
                
                setTimeout(() => {
                    hexGroup.classList.remove('tile-flash');
                    console.log('Removed tile-flash class');
                }, 473);
            }

            animateTileRemoval(player, originalPosition, callback) {
                console.log('=== TILE REMOVAL DEBUG ===');
                console.log('Player:', player, 'Original Position:', originalPosition);
                console.log('Selected Tile:', this.selectedTile);
                
                if (originalPosition === null || originalPosition === undefined) {
                    console.log('No valid originalPosition, skipping animation');
                    callback();
                    return;
                }
                
                // Find the tile container in the player panel
                const panelId = player === 1 ? 'player1Tiles' : 'player2Tiles';
                const panel = document.getElementById(panelId);
                
                if (!panel) {
                    console.log('Panel not found:', panelId);
                    callback();
                    return;
                }
                
                const tileContainers = panel.querySelectorAll('.tile-container');
                console.log('Found tile containers:', tileContainers.length);
                
                // Debug all containers
                tileContainers.forEach((container, index) => {
                    const isEmpty = container.classList.contains('empty-tile');
                    const tileText = container.querySelector('text');
                    const tileValue = tileText ? tileText.textContent : 'no text';
                    console.log(`Container ${index}: empty=${isEmpty}, value=${tileValue}`);
                });
                
                // Find the tile at the original position that matches the selected tile value
                let targetTile = null;
                tileContainers.forEach((container, index) => {
                    if (index === originalPosition && !container.classList.contains('empty-tile')) {
                        const tileText = container.querySelector('text');
                        const tileValue = tileText ? parseInt(tileText.textContent) : null;
                        console.log(`Checking position ${index}: tile value ${tileValue} vs selected ${this.selectedTile}`);
                        
                        if (tileValue === this.selectedTile) {
                            targetTile = container;
                            console.log('✓ Found matching tile at position:', index);
                        }
                    }
                });
                
                if (targetTile) {
                    console.log('🎬 Starting tile removal animation on:', targetTile);
                    
                    // Add removal animation
                    targetTile.classList.add('removing');
                    
                    // Execute callback after animation completes
                    setTimeout(() => {
                        console.log('✅ Tile removal animation complete');
                        targetTile.classList.remove('removing'); // Clean up
                        callback();
                    }, 3000); // Match animation duration
                } else {
                    console.log('❌ Target tile not found at position', originalPosition);
                    console.log('Available tiles:', Array.from(tileContainers).map((c, i) => {
                        const text = c.querySelector('text');
                        return `${i}:${text ? text.textContent : 'empty'}`;
                    }).join(', '));
                    callback();
                }
            }

            showQuickTileSelector(hexId, event) {
                const selector = document.getElementById('quickTileSelector');
                const grid = document.getElementById('quickTilesGrid');
                
                // If selector is already open for this hex, close it
                if (selector.style.display === 'block' && selector.getAttribute('data-target-hex') === hexId.toString()) {
                    this.hideQuickTileSelector();
                    return;
                }
                
                // Remove any existing outside click listeners
                this.cleanupQuickTileSelectorListeners();
                
                // Clear previous tiles
                grid.innerHTML = '';
                
                // Always show only current player's tiles (in both normal and analysis mode)
                // Get current player's available tiles
                const playerTiles = this.currentPlayer === 1 ? this.player1Tiles : this.player2Tiles;
                const playerOriginalTiles = this.currentPlayer === 1 ? this.player1OriginalTiles : this.player2OriginalTiles;
                const playerUsedPositions = this.currentPlayer === 1 ? this.player1UsedPositions : this.player2UsedPositions;
                
                // Create tiles for each available tile and count them
                let availableTileCount = 0;
                playerOriginalTiles.forEach((tileValue, index) => {
                    if (!playerUsedPositions.has(index)) {
                        const tileElement = this.createQuickTile(tileValue, this.currentPlayer, index, hexId);
                        grid.appendChild(tileElement);
                        availableTileCount++;
                    }
                });
                
                // Set grid columns to match available tile count
                grid.style.gridTemplateColumns = `repeat(${availableTileCount || 1}, 1fr)`;
                
                // Position the selector above the hex (centered horizontally based on actual tile count)
                const rect = event.target.getBoundingClientRect();
                const tileWidth = 50;
                const gapWidth = 2;
                const padding = 12; // 6px padding on each side
                const actualSelectorWidth = availableTileCount * tileWidth + (availableTileCount - 1) * gapWidth + padding;
                
                selector.style.left = (rect.left + rect.width / 2 - actualSelectorWidth / 2) + 'px';
                selector.style.top = (rect.top - 30) + 'px';
                selector.style.display = 'block';
                
                // Trigger animation after a small delay to ensure display is set
                requestAnimationFrame(() => {
                    selector.classList.add('show');
                });
                
                // Store the target hex for later use
                selector.setAttribute('data-target-hex', hexId);
                
                // Add click outside listener to hide selector with a small delay to prevent immediate closure
                this.outsideClickHandler = this.hideQuickTileSelectorOnOutsideClick.bind(this);
                setTimeout(() => {
                    document.addEventListener('click', this.outsideClickHandler, { once: true });
                }, 10);
            }

            createQuickTile(value, player, originalPosition, targetHexId) {
                const tileContainer = document.createElement('div');
                tileContainer.className = 'quick-tile';
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('viewBox', '0 0 100 86');
                
                const hexagon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                // Calculate equilateral hexagon points (center at 50,43, radius 34)
                const cx = 50, cy = 43, r = 34;
                const points = [];
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    const x = cx + r * Math.cos(angle);
                    const y = cy + r * Math.sin(angle);
                    points.push(`${x.toFixed(1)},${y.toFixed(1)}`);
                }
                hexagon.setAttribute('points', points.join(' '));
                hexagon.setAttribute('fill', '#ffd700');
                hexagon.setAttribute('stroke', '#ddd');
                hexagon.setAttribute('stroke-width', '2');
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', '50');
                text.setAttribute('y', '43');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'central');
                text.setAttribute('font-family', 'Inter, Arial, sans-serif');
                text.setAttribute('font-size', '36');
                text.setAttribute('font-weight', '600');
                text.setAttribute('fill', player === 1 ? '#c0392b' : '#2980b9');
                text.textContent = value;
                
                svg.appendChild(hexagon);
                svg.appendChild(text);
                tileContainer.appendChild(svg);
                
                // Add click handler
                tileContainer.onclick = () => {
                    console.log('Quick tile selector clicked - setting originalPosition:', originalPosition);
                    this.selectTile(player, value, originalPosition);
                    this.makeMove(targetHexId, value);
                    this.hideQuickTileSelector();
                };
                
                return tileContainer;
            }

            hideQuickTileSelector() {
                const selector = document.getElementById('quickTileSelector');
                selector.classList.remove('show');
                this.cleanupQuickTileSelectorListeners();
                
                // Hide after animation completes
                setTimeout(() => {
                    if (!selector.classList.contains('show')) {
                        selector.style.display = 'none';
                    }
                }, 200); // Match animation duration
            }

            cleanupQuickTileSelectorListeners() {
                // Remove any existing outside click listeners
                if (this.outsideClickHandler) {
                    document.removeEventListener('click', this.outsideClickHandler);
                    this.outsideClickHandler = null;
                }
            }

            hideQuickTileSelectorOnOutsideClick(event) {
                const selector = document.getElementById('quickTileSelector');
                
                // Check if click is on selector itself
                if (selector.contains(event.target)) {
                    return;
                }
                
                // Check if click is on a hex that would open a new selector
                const hexElement = event.target.closest('[data-id]');
                if (hexElement && this.selectedTile === null) {
                    const hexId = parseInt(hexElement.getAttribute('data-id'));
                    const validMoves = this.getValidMoves();
                    if (validMoves.includes(hexId)) {
                        // Don't hide - let the new selector open
                        return;
                    }
                }
                
                // Hide the selector for any other click
                this.hideQuickTileSelector();
            }

            getValidMoves() {
                const validMoves = [];
                
                this.board.board.forEach(hex => {
                    if (hex.value === null && this.isMoveLegal(hex.id)) {
                        validMoves.push(hex.id);
                    }
                });

                return validMoves;
            }

            isMoveLegal(hexId) {
                const hex = this.board.board[hexId];
                
                console.log('Checking move legality for hex:', hexId, hex);
                
                // Check if hex is empty
                if (hex.value !== null) {
                    console.log('Hex not empty');
                    return false;
                }

                // Check if adjacent to an occupied hex
                const adjacentHexes = this.getAdjacentHexes(hexId);
                console.log('Adjacent hexes:', adjacentHexes);
                
                const hasAdjacentOccupied = adjacentHexes.some(id => 
                    this.board.board[id] && this.board.board[id].value !== null
                );

                console.log('Has adjacent occupied:', hasAdjacentOccupied);
                
                if (!hasAdjacentOccupied) return false;

                // Check chain length constraint
                const chainOk = this.checkChainLengthConstraint(hexId);
                console.log('Chain constraint ok:', chainOk);
                
                return chainOk;
            }

            getAdjacentHexes(hexId) {
                const hex = this.board.board[hexId];
                const adjacent = [];
                
                // Use the same direction offsets as the Java code
                const directions = [
                    {dr: -2, dc: 0},   // UP
                    {dr: -1, dc: 1},   // UPRIGHT
                    {dr: 1, dc: 1},    // DOWNRIGHT
                    {dr: 2, dc: 0},    // DOWN
                    {dr: 1, dc: -1},   // DOWNLEFT
                    {dr: -1, dc: -1}   // UPLEFT
                ];

                directions.forEach(({dr, dc}) => {
                    const adjHex = this.board.board.find(h => 
                        h.row === hex.row + dr && h.col === hex.col + dc
                    );
                    if (adjHex) {
                        adjacent.push(adjHex.id);
                    }
                });

                return adjacent;
            }

            checkChainLengthConstraint(hexId) {
                // Order 1 games have no length constraint
                if (this.board.board.length === 7) return true;
                
                // Make a test board with the proposed move
                const testBoard = JSON.parse(JSON.stringify(this.board.board));
                testBoard[hexId].value = 1; // Use dummy value for testing
                testBoard[hexId].owner = `player${this.currentPlayer}`;
                
                // Get chain lengths AFTER the hypothetical placement
                const newChainLengths = this.getFirstAndSecondChainLengthsForBoard(testBoard);
                
                // Rule: longest chain can be at most 1 longer than second longest
                // This accounts for moves that simultaneously create new longest AND second longest
                if (newChainLengths.first > newChainLengths.second + 1) {
                    return false;
                }
                
                return true;
            }

            getFirstAndSecondChainLengths() {
                return this.getFirstAndSecondChainLengthsForBoard(this.board.board);
            }

            getFirstAndSecondChainLengthsForBoard(boardState) {
                const allChainLengths = this.getAllChainLengthsForBoard(boardState);
                let first = 0, second = 0;
                
                allChainLengths.forEach(length => {
                    if (length > first) {
                        second = first;
                        first = length;
                    } else if (length > second) {
                        second = length;
                    }
                });
                
                return { first, second };
            }

            getAllChainLengthsForBoard(boardState) {
                const chainLengths = [];
                
                // All possible chain starters and directions from RulesV1.java
                const chainStarters = [
                    {start: 0, dir: {dr: 1, dc: -1}}, // DOWNLEFT
                    {start: 0, dir: {dr: 2, dc: 0}},  // DOWN
                    {start: 0, dir: {dr: 1, dc: 1}},  // DOWNRIGHT
                    {start: 1, dir: {dr: 2, dc: 0}},  // DOWN
                    {start: 1, dir: {dr: 1, dc: 1}},  // DOWNRIGHT
                    {start: 2, dir: {dr: 1, dc: -1}}, // DOWNLEFT
                    {start: 2, dir: {dr: 2, dc: 0}},  // DOWN
                    {start: 3, dir: {dr: 2, dc: 0}},  // DOWN
                    {start: 3, dir: {dr: 1, dc: 1}},  // DOWNRIGHT
                    {start: 5, dir: {dr: 1, dc: -1}}, // DOWNLEFT
                    {start: 5, dir: {dr: 2, dc: 0}},  // DOWN
                    {start: 8, dir: {dr: 1, dc: 1}},  // DOWNRIGHT
                    {start: 10, dir: {dr: 1, dc: -1}}, // DOWNLEFT
                    {start: 13, dir: {dr: 1, dc: 1}}, // DOWNRIGHT
                    {start: 15, dir: {dr: 1, dc: -1}} // DOWNLEFT
                ];
                
                chainStarters.forEach(({start, dir}) => {
                    const lengths = this.getChainLengthsFromStart(boardState, start, dir);
                    chainLengths.push(...lengths);
                });
                
                return chainLengths;
            }

            getChainLengthsFromStart(boardState, startId, direction) {
                const lengths = [];
                let currentLength = 0;
                let current = startId;
                
                while (current !== null) {
                    const hex = boardState.find(h => h.id === current);
                    if (!hex) break;
                    
                    if (hex.value !== null) {
                        currentLength++;
                    } else if (currentLength > 0) {
                        // Hit empty cell, record current chain and reset
                        lengths.push(currentLength);
                        currentLength = 0;
                    }
                    
                    // Move to next cell in direction
                    const nextHex = boardState.find(h => 
                        h.row === hex.row + direction.dr && h.col === hex.col + direction.dc
                    );
                    current = nextHex ? nextHex.id : null;
                }
                
                // Record final chain if we ended on occupied cells
                if (currentLength > 0) {
                    lengths.push(currentLength);
                }
                
                return lengths;
            }

            makeMove(hexId, tileValue) {
                console.log('=== MAKE MOVE DEBUG ===');
                console.log('Hex ID:', hexId, 'Tile Value:', tileValue);
                console.log('Selected Original Position:', this.selectedOriginalPosition);
                console.log('Selected Tile:', this.selectedTile);
                console.log('Current Player:', this.currentPlayer);
                
                if (!this.isMoveLegal(hexId)) {
                    // Check if it's specifically a chain length violation
                    const hasAdjacentOccupied = this.getAdjacentHexes(hexId).some(adjId => 
                        this.board.board[adjId].value !== null
                    );
                    
                    if (hasAdjacentOccupied && !this.checkChainLengthConstraint(hexId)) {
                        this.showMessage('Invalid move! Chain Length Violation', 'error');
                    } else {
                        this.showMessage('Invalid move! Not Adjacent Tile', 'error');
                    }
                    return;
                }

                // Clear ghost previews when making a move (with animation transition)
                this.clearGhostPreviewWithTransition(hexId);

                // In analysis mode, use the selected player's tile
                const movePlayer = this.isAnalysisMode ? this.selectedPlayer : this.currentPlayer;

                // Save move to appropriate history
                if (this.isAnalysisMode) {
                    // Save to analysis move history
                    this.analysisMoveHistory.push({
                        hexId: hexId,
                        tileValue: tileValue,
                        player: movePlayer,
                        player1Tiles: [...this.player1Tiles],
                        player2Tiles: [...this.player2Tiles],
                        player1UsedPositions: new Set(this.player1UsedPositions),
                        player2UsedPositions: new Set(this.player2UsedPositions),
                        originalPosition: this.selectedOriginalPosition,
                        previousValue: this.board.board[hexId].value,
                        previousOwner: this.board.board[hexId].owner
                    });
                } else {
                    // Save to regular move history
                    this.moveHistory.push({
                        hexId: hexId,
                        tileValue: tileValue,
                        player: this.currentPlayer,
                        player1Tiles: [...this.player1Tiles],
                        player2Tiles: [...this.player2Tiles],
                        player1UsedPositions: new Set(this.player1UsedPositions),
                        player2UsedPositions: new Set(this.player2UsedPositions),
                        originalPosition: this.selectedOriginalPosition
                    });
                }

                // Place tile
                this.board.board[hexId].value = tileValue;
                this.board.board[hexId].owner = `player${movePlayer}`;

                // Animate tile removal and then mark as used
                console.log('🔥 ABOUT TO CALL animateTileRemoval with:', movePlayer, this.selectedOriginalPosition);
                this.animateTileRemoval(movePlayer, this.selectedOriginalPosition, () => {
                    // Mark the original position as used and remove from available tiles
                    if (movePlayer === 1) {
                        // Mark position as used
                        if (this.selectedOriginalPosition !== null) {
                            this.player1UsedPositions.add(this.selectedOriginalPosition);
                        }
                        // Remove from available tiles
                        const index = this.player1Tiles.indexOf(tileValue);
                        if (index > -1) {
                            this.player1Tiles.splice(index, 1);
                        }
                    } else {
                        // Mark position as used
                        if (this.selectedOriginalPosition !== null) {
                            this.player2UsedPositions.add(this.selectedOriginalPosition);
                        }
                        // Remove from available tiles
                        const index = this.player2Tiles.indexOf(tileValue);
                        if (index > -1) {
                            this.player2Tiles.splice(index, 1);
                        }
                    }
                });

                // Clear selection and suggestion
                this.selectedTile = null;
                this.selectedTileIndex = null;
                this.selectedOriginalPosition = null;
                this.suggestedMove = null;
                this.board.setSelectedTile(null);

                // Redraw board
                this.board.drawBoard(document.getElementById('gameBoard'), this.suggestedMove, this);
                
                // Trigger tile placement animation
                this.animateTilePlacement(hexId);

                // Update scores
                this.updateScores();

                // Highlight chains affected by this move (before checking game end)
                this.highlightAffectedChains(hexId);

                // In analysis mode, don't check for game end or switch players
                if (!this.isAnalysisMode) {
                    // Check for game end
                    if (this.isGameOver()) {
                        // Update tile display to remove the last tile before showing end game
                        this.updateTileDisplay();
                        this.endGame();
                        return;
                    }

                    // Switch players
                    this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                    this.updateTurnIndicator();
                    this.updateTileDisplay();
                    this.updatePanelHighlight();
                    this.updateTileSetButtonState();
                    
                    this.showMessage('', '');
                } else {
                    // In analysis mode, also switch players and check for game end
                    if (this.isGameOver()) {
                        this.updateTileDisplay();
                        this.showMessage('Game would end here. Use Undo to continue exploring.', 'info');
                        return;
                    }
                    
                    // Switch players in analysis mode too
                    this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                    this.updateTurnIndicator();
                    this.updateTileDisplay();
                    this.updatePanelHighlight();
                    this.showMessage('Analysis Mode: Continue placing tiles to explore', 'success');
                }
            }
            
            // Find which chains contain the given hex ID
            getChainsContainingHex(hexId) {
                const affectedChains = [];
                
                // Check player 1 chains
                this.chainDefinitions.player1.forEach((chain, index) => {
                    if (chain.includes(hexId)) {
                        affectedChains.push({player: 1, chainIndex: index, hexIds: chain});
                    }
                });
                
                // Check player 2 chains
                this.chainDefinitions.player2.forEach((chain, index) => {
                    if (chain.includes(hexId)) {
                        affectedChains.push({player: 2, chainIndex: index, hexIds: chain});
                    }
                });
                
                return affectedChains;
            }
            
            // Highlight chains that contain the placed hex
            highlightAffectedChains(hexId) {
                const affectedChains = this.getChainsContainingHex(hexId);
                
                affectedChains.forEach((chainInfo, index) => {
                    // Add small delay between multiple chains
                    setTimeout(() => {
                        this.drawChainLine(chainInfo.hexIds, chainInfo.player);
                    }, index * 200);
                });
            }
            
            // Draw a line connecting hexes in a chain
            drawChainLine(hexIds, player) {
                const svg = document.getElementById('gameBoard');
                
                if (!svg) {
                    console.log('SVG element not found');
                    return;
                }
                
                console.log('Drawing chain line for player', player, 'hexIds:', hexIds);
                
                // Create path through all hexes in the chain
                let pathData = '';
                for (let i = 0; i < hexIds.length; i++) {
                    const hex = this.board.board[hexIds[i]];
                    console.log(`Hex ${hexIds[i]}: x=${hex.x}, y=${hex.y}`);
                    if (i === 0) {
                        pathData += `M ${hex.x} ${hex.y}`;
                    } else {
                        pathData += ` L ${hex.x} ${hex.y}`;
                    }
                }
                
                console.log('Path data:', pathData);
                
                // Create the line element
                const chainLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                chainLine.setAttribute('d', pathData);
                chainLine.setAttribute('class', `chain-line player${player} flash`);
                chainLine.setAttribute('id', `chain-${player}-${Date.now()}`);
                
                console.log('Created chain line element:', chainLine);
                
                // Add to SVG
                svg.appendChild(chainLine);
                
                // Remove after animation completes
                setTimeout(() => {
                    if (chainLine.parentNode) {
                        chainLine.parentNode.removeChild(chainLine);
                    }
                }, 1500);
            }

            undo() {
                // Handle undo differently in analysis mode
                if (this.isAnalysisMode) {
                    if (this.analysisMoveHistory.length === 0) {
                        this.showMessage('No analysis moves to undo!', 'error');
                        return;
                    }
                    
                    // Undo analysis move
                    const lastMove = this.analysisMoveHistory.pop();
                    
                    // Restore the board state
                    this.board.board[lastMove.hexId].value = lastMove.previousValue;
                    this.board.board[lastMove.hexId].owner = lastMove.previousOwner;
                    
                    // Restore player tiles
                    this.player1Tiles = [...lastMove.player1Tiles];
                    this.player2Tiles = [...lastMove.player2Tiles];
                    
                    // Restore used positions
                    this.player1UsedPositions = lastMove.player1UsedPositions;
                    this.player2UsedPositions = lastMove.player2UsedPositions;
                    
                    // Clear selections
                    this.selectedTile = null;
                    this.selectedTileIndex = null;
                    this.selectedOriginalPosition = null;
                    this.board.setSelectedTile(null);
                    
                    // Redraw
                    this.board.drawBoard(document.getElementById('gameBoard'), this.suggestedMove, this);
                    this.updateScores();
                    this.updateTileDisplay();
                    this.updatePanelHighlight();
                    
                    this.showMessage('Analysis move undone!', 'success');
                    return;
                }
                
                // Regular undo (not in analysis mode)
                // Check if we can undo a reset
                if (this.preResetState) {
                    this.undoReset();
                    return;
                }
                
                if (this.moveHistory.length === 0) {
                    this.showMessage('No moves to undo!', 'error');
                    return;
                }

                // Get the last move
                const lastMove = this.moveHistory.pop();

                // Restore the board state
                this.board.board[lastMove.hexId].value = null;
                this.board.board[lastMove.hexId].owner = null;

                // Restore player tiles
                this.player1Tiles = [...lastMove.player1Tiles];
                this.player2Tiles = [...lastMove.player2Tiles];
                
                // Restore used positions
                this.player1UsedPositions = lastMove.player1UsedPositions || new Set();
                this.player2UsedPositions = lastMove.player2UsedPositions || new Set();

                // Restore current player
                this.currentPlayer = lastMove.player;

                // Clear game ended state and hide status displays
                this.gameEnded = false;
                document.getElementById('player1Status').style.display = 'none';
                document.getElementById('player2Status').style.display = 'none';
                
                // Remove winner animations
                document.getElementById('player1Panel').classList.remove('winner');
                document.getElementById('player2Panel').classList.remove('winner');

                // Clear selections and suggestions
                this.selectedTile = null;
                this.selectedTileIndex = null;
                this.selectedOriginalPosition = null;
                this.suggestedMove = null;
                this.board.setSelectedTile(null);

                // Redraw board
                this.board.drawBoard(document.getElementById('gameBoard'), this.suggestedMove, this);

                // Update UI
                this.updateScores();
                this.updateTurnIndicator();
                this.updateTileDisplay();
                this.updatePanelHighlight();

                this.showMessage('Move undone!', 'success');
            }

            updateScores() {
                const scores = this.calculateScores();
                this.animateScore('player1Score', scores.player1);
                this.animateScore('player2Score', scores.player2);
            }
            
            animateScore(elementId, targetScore) {
                const element = document.getElementById(elementId);
                const currentText = element.textContent;
                const currentScore = parseInt(currentText.match(/\d+/)?.[0] || '0');
                
                // If scores are the same, no animation needed
                if (currentScore === targetScore) return;
                
                // Cancel any existing animation for this element
                if (element.scoreAnimation) {
                    cancelAnimationFrame(element.scoreAnimation);
                }
                
                const startScore = currentScore;
                const scoreDiff = targetScore - startScore;
                const duration = Math.min(600, Math.abs(scoreDiff) * 4 + 200); // Responsive duration (100% slower)
                const startTime = performance.now();
                
                const animate = (currentTime) => {
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function for smooth animation
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    const currentValue = Math.round(startScore + (scoreDiff * easeOut));
                    
                    element.textContent = `Score: ${currentValue}`;
                    
                    if (progress < 1) {
                        element.scoreAnimation = requestAnimationFrame(animate);
                    } else {
                        element.scoreAnimation = null;
                        element.textContent = `Score: ${targetScore}`; // Ensure exact final value
                    }
                };
                
                element.scoreAnimation = requestAnimationFrame(animate);
            }

            calculateScores() {
                return this.calculateScoresForBoard(this.board.board);
            }

            calculateScoresForBoard(boardState) {
                console.log('=== SCORING DEBUG ===');
                console.log('Board state:', boardState.map(h => ({id: h.id, row: h.row, col: h.col, value: h.value})));
                
                let player1Score = 0;
                let player2Score = 0;

                // Player 1 DOWNRIGHT diagonal chains
                const player1Chains = [
                    [0, 2, 5],        // AA - CC - FF
                    [1, 4, 7, 10],    // BB - EE - HH - KK
                    [3, 6, 9, 12, 15], // DD - GG - JJ - MM - PP
                    [8, 11, 14, 17],  // II - LL - OO - RR
                    [13, 16, 18]      // NN - QQ - SS
                ];

                const player2Chains = [
                    [0, 1, 3],        // AA - BB - DD
                    [2, 4, 6, 8],     // CC - EE - GG - II
                    [5, 7, 9, 11, 13], // FF - HH - JJ - LL - NN
                    [12, 14, 16, 10], // MM - OO - QQ - KK (fixed to include KK)
                    [15, 17, 18]      // PP - RR - SS
                ];

                // Calculate Player 1 score
                console.log('=== PLAYER 1 CHAINS ===');
                player1Chains.forEach((chain, index) => {
                    let lineProduct = 1;
                    const values = [];
                    let hasAnyTiles = false;
                    
                    chain.forEach(hexId => {
                        const hex = boardState.find(h => h.id === hexId);
                        const value = (hex && hex.value !== null) ? hex.value : 1;
                        values.push(value);
                        lineProduct *= value;
                        if (hex && hex.value !== null) {
                            hasAnyTiles = true;
                        }
                    });
                    
                    // If chain has no tiles placed, score is 0
                    if (!hasAnyTiles) {
                        lineProduct = 0;
                    }
                    
                    console.log(`P1 Chain ${index + 1} [${chain.join(',')}]: ${values.join(' x ')} = ${lineProduct} ${!hasAnyTiles ? '(empty chain)' : ''}`);
                    player1Score += lineProduct;
                });

                // Calculate Player 2 score
                console.log('=== PLAYER 2 CHAINS ===');
                player2Chains.forEach((chain, index) => {
                    let lineProduct = 1;
                    const values = [];
                    let hasAnyTiles = false;
                    
                    chain.forEach(hexId => {
                        const hex = boardState.find(h => h.id === hexId);
                        const value = (hex && hex.value !== null) ? hex.value : 1;
                        values.push(value);
                        lineProduct *= value;
                        if (hex && hex.value !== null) {
                            hasAnyTiles = true;
                        }
                    });
                    
                    // If chain has no tiles placed, score is 0
                    if (!hasAnyTiles) {
                        lineProduct = 0;
                    }
                    
                    console.log(`P2 Chain ${index + 1} [${chain.join(',')}]: ${values.join(' x ')} = ${lineProduct} ${!hasAnyTiles ? '(empty chain)' : ''}`);
                    player2Score += lineProduct;
                });

                console.log('Player 1 total:', player1Score);
                console.log('Player 2 total:', player2Score);
                return { player1: player1Score, player2: player2Score };
            }

            updateTurnIndicator() {
                if (this.isAnalysisMode) {
                    document.getElementById('turnIndicator').textContent = 
                        `Analysis Mode - Player ${this.currentPlayer}'s Turn`;
                } else {
                    document.getElementById('turnIndicator').textContent = 
                        `Player ${this.currentPlayer}'s Turn`;
                }
            }

            updatePanelHighlight() {
                // Always highlight the current player's panel
                document.getElementById('player1Panel').classList.toggle('active', this.currentPlayer === 1);
                document.getElementById('player2Panel').classList.toggle('active', this.currentPlayer === 2);
            }


            isGameOver() {
                // Check if all hexes are filled
                return this.board.board.every(hex => hex.value !== null);
            }

            endGame() {
                this.gameEnded = true;
                const scores = this.calculateScores();
                
                // Update turn indicator to show GAME OVER
                document.getElementById('turnIndicator').textContent = 'GAME OVER';
                
                const player1Status = document.getElementById('player1Status');
                const player2Status = document.getElementById('player2Status');
                const player1Panel = document.getElementById('player1Panel');
                const player2Panel = document.getElementById('player2Panel');
                
                if (scores.player1 > scores.player2) {
                    const pointDiff = scores.player1 - scores.player2;
                    player1Status.textContent = 'WINNER';
                    player1Status.className = 'game-status winner';
                    player2Status.textContent = 'LOSER';
                    player2Status.className = 'game-status loser';
                    
                    // Add winner animations
                    player1Panel.classList.add('winner');
                    this.createConfetti(player1Panel);
                    this.showMessage(`Player 1 Wins by ${pointDiff} Points`, 'success');
                } else if (scores.player2 > scores.player1) {
                    const pointDiff = scores.player2 - scores.player1;
                    player1Status.textContent = 'LOSER';
                    player1Status.className = 'game-status loser';
                    player2Status.textContent = 'WINNER';
                    player2Status.className = 'game-status winner';
                    
                    // Add winner animations
                    player2Panel.classList.add('winner');
                    this.createConfetti(player2Panel);
                    this.showMessage(`Player 2 Wins by ${pointDiff} Points`, 'success');
                } else {
                    player1Status.textContent = 'TIE';
                    player1Status.className = 'game-status tie';
                    player2Status.textContent = 'TIE';
                    player2Status.className = 'game-status tie';
                    this.showMessage('It\'s a Tie!', '');
                }

                player1Status.style.display = 'block';
                player2Status.style.display = 'block';
            }

            createConfetti(winnerPanel) {
                const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#9400d3', '#ff1493', '#00ffff', '#ff69b4'];
                const panelRect = winnerPanel.getBoundingClientRect();
                
                // Create confetti from multiple points around the winner panel
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const confetti = document.createElement('div');
                        confetti.className = 'confetti';
                        
                        // Random color
                        confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                        
                        // Random starting position along the edges of the winner panel
                        const side = Math.floor(Math.random() * 4); // 0=top, 1=right, 2=bottom, 3=left
                        let startX, startY;
                        
                        switch(side) {
                            case 0: // top
                                startX = panelRect.left + Math.random() * panelRect.width;
                                startY = panelRect.top;
                                break;
                            case 1: // right
                                startX = panelRect.right;
                                startY = panelRect.top + Math.random() * panelRect.height;
                                break;
                            case 2: // bottom
                                startX = panelRect.left + Math.random() * panelRect.width;
                                startY = panelRect.bottom;
                                break;
                            case 3: // left
                                startX = panelRect.left;
                                startY = panelRect.top + Math.random() * panelRect.height;
                                break;
                        }
                        
                        confetti.style.left = startX + 'px';
                        confetti.style.top = startY + 'px';
                        
                        // Random size
                        const size = 5 + Math.random() * 10;
                        confetti.style.width = size + 'px';
                        confetti.style.height = size + 'px';
                        
                        // Random rotation and animation duration
                        const duration = 2 + Math.random() * 2;
                        confetti.style.animationDuration = duration + 's';
                        
                        document.body.appendChild(confetti);
                        
                        // Remove confetti after animation
                        setTimeout(() => {
                            if (confetti.parentNode) {
                                confetti.parentNode.removeChild(confetti);
                            }
                        }, duration * 1000);
                    }, Math.random() * 1000); // Stagger the confetti creation
                }
            }

            suggestMove() {
                console.log('Suggest move clicked');
                
                const validMoves = this.getValidMoves();
                console.log('Valid moves for suggestion:', validMoves);
                
                if (validMoves.length === 0) {
                    console.log('No valid moves available');
                    this.showMessage('No valid moves available', 'error');
                    return;
                }

                // Find best move by evaluating all valid tile-position combinations
                let bestScore = -Infinity;
                let bestMove = null;
                
                const availableTiles = this.currentPlayer === 1 ? this.player1Tiles : this.player2Tiles;
                console.log('Available tiles:', availableTiles);
                
                validMoves.forEach(hexId => {
                    availableTiles.forEach(tileValue => {
                        // Simulate placing this tile
                        const score = this.evaluateMove(hexId, tileValue);
                        console.log(`Move ${tileValue} at ${hexId}: score = ${score}`);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = {hexId, tileValue};
                        }
                    });
                });

                console.log('Best move found:', bestMove, 'with score:', bestScore);

                if (bestMove) {
                    // Clear any previous suggestion
                    this.suggestedMove = bestMove;
                    console.log('Setting suggested move:', this.suggestedMove);
                    
                    // Redraw board to show suggestion
                    this.board.drawBoard(document.getElementById('gameBoard'), this.suggestedMove, this);
                    this.showMessage('', '');
                } else {
                    console.log('No best move found');
                    this.showMessage('No optimal move found', 'error');
                }
            }

            evaluateMove(hexId, tileValue) {
                // Simple heuristic evaluation - much faster!
                const testBoard = JSON.parse(JSON.stringify(this.board.board));
                testBoard[hexId].value = tileValue;
                testBoard[hexId].owner = `player${this.currentPlayer}`;
                
                // Calculate immediate score difference
                const scores = this.calculateScoresForBoard(testBoard);
                let scoreDiff = this.currentPlayer === 1 ? 
                               (scores.player1 - scores.player2) : 
                               (scores.player2 - scores.player1);
                
                // Add positional bonus for strategic cells
                const positionBonus = this.getPositionBonus(hexId, tileValue);
                
                return scoreDiff + positionBonus;
            }

            getPositionBonus(hexId, tileValue) {
                // Simple heuristic bonuses
                let bonus = 0;
                
                // Bonus for higher value tiles
                bonus += tileValue * 10;
                
                // Bonus for cells that appear in multiple chains
                const myChains = this.currentPlayer === 1 ? 
                    [[0, 2, 5], [1, 4, 7, 10], [3, 6, 9, 12, 15], [8, 11, 14, 17], [13, 16, 18]] :
                    [[0, 1, 3], [2, 4, 6, 8], [5, 7, 9, 11, 13], [12, 14, 16, 10], [15, 17, 18]];
                
                let chainCount = 0;
                myChains.forEach(chain => {
                    if (chain.includes(hexId)) chainCount++;
                });
                bonus += chainCount * 50;
                
                // Bonus for center-area positions (more connections)
                const centerPositions = [4, 6, 7, 9, 11, 12];
                if (centerPositions.includes(hexId)) {
                    bonus += 30;
                }
                
                return bonus;
            }

            reset() {
                // Disable reset in analysis mode
                if (this.isAnalysisMode) {
                    this.showMessage('Reset Game is disabled in Analysis Mode. Use Undo to clear the board.', 'error');
                    return;
                }
                
                // Nothing to reset if no moves have been made
                if (this.moveHistory.length === 0) {
                    this.showMessage('No moves to reset!', 'error');
                    return;
                }
                
                // Clear any existing preResetState to prevent stacking multiple game states
                // This ensures we can only undo the most recent reset, preventing old game state leakage
                if (this.preResetState) {
                    console.log('Clearing previous reset state to prevent stacking');
                    this.preResetState = null;
                }
                
                // Save current game state before resetting
                this.preResetState = {
                    board: this.board.clone(),
                    currentPlayer: this.currentPlayer,
                    player1Tiles: [...this.player1Tiles],
                    player2Tiles: [...this.player2Tiles],
                    player1UsedPositions: new Set(this.player1UsedPositions),
                    player2UsedPositions: new Set(this.player2UsedPositions),
                    selectedTile: this.selectedTile,
                    selectedTileIndex: this.selectedTileIndex,
                    suggestedMove: this.suggestedMove,
                    moveHistory: [...this.moveHistory],
                    gameEnded: this.gameEnded,
                    player1Status: document.getElementById('player1Status').style.display,
                    player2Status: document.getElementById('player2Status').style.display,
                    messageText: document.getElementById('message').textContent,
                    messageClass: document.getElementById('message').className
                };
                
                this.board = new HexBoard();
                this.currentPlayer = 1;
                // Preserve current tile sets instead of resetting to default
                this.player1Tiles = [...this.player1OriginalTiles];
                this.player2Tiles = [...this.player2OriginalTiles];
                this.player1UsedPositions = new Set(); // Track which positions have been used
                this.player2UsedPositions = new Set(); // Track which positions have been used
                this.selectedTile = null;
                this.selectedTileIndex = null;
                this.selectedOriginalPosition = null; // Track the original position of selected tile
                this.suggestedMove = null;
                this.moveHistory = [];
                this.gameEnded = false;
                
                // Hide status displays
                document.getElementById('player1Status').style.display = 'none';
                document.getElementById('player2Status').style.display = 'none';
                
                // Remove winner animations
                document.getElementById('player1Panel').classList.remove('winner');
                document.getElementById('player2Panel').classList.remove('winner');
                
                this.init();
                this.updatePanelHighlight();
                this.showMessage('Game reset! You can undo this reset with the Undo button.', '');
            }

            undoReset() {
                if (!this.preResetState) return;
                
                this.board = this.preResetState.board;
                this.currentPlayer = this.preResetState.currentPlayer;
                this.player1Tiles = this.preResetState.player1Tiles;
                this.player2Tiles = this.preResetState.player2Tiles;
                this.player1UsedPositions = this.preResetState.player1UsedPositions;
                this.player2UsedPositions = this.preResetState.player2UsedPositions;
                this.selectedTile = this.preResetState.selectedTile;
                this.selectedTileIndex = this.preResetState.selectedTileIndex;
                this.suggestedMove = this.preResetState.suggestedMove;
                this.moveHistory = this.preResetState.moveHistory;
                this.gameEnded = this.preResetState.gameEnded;
                
                // Restore status displays
                document.getElementById('player1Status').style.display = this.preResetState.player1Status;
                document.getElementById('player2Status').style.display = this.preResetState.player2Status;
                
                // Restore message
                document.getElementById('message').textContent = this.preResetState.messageText;
                document.getElementById('message').className = this.preResetState.messageClass;
                
                this.preResetState = null;
                
                // Redraw board and update displays
                this.board.drawBoard(document.getElementById('gameBoard'), this.suggestedMove, this);
                this.updateScores();
                this.updateTurnIndicator();
                this.updateTileDisplay();
                this.updatePanelHighlight();
                this.updateResetButtonState();
            }

            // Analysis Mode Methods
            toggleAnalysisMode() {
                if (this.isAnalysisMode) {
                    this.exitAnalysisMode();
                } else {
                    this.enterAnalysisMode();
                }
            }

            enterAnalysisMode() {
                // Save complete game state
                this.preAnalysisState = {
                    board: this.board.clone(),
                    currentPlayer: this.currentPlayer,
                    player1Tiles: [...this.player1Tiles],
                    player2Tiles: [...this.player2Tiles],
                    player1OriginalTiles: [...this.player1OriginalTiles],
                    player2OriginalTiles: [...this.player2OriginalTiles],
                    player1UsedPositions: new Set(this.player1UsedPositions),
                    player2UsedPositions: new Set(this.player2UsedPositions),
                    selectedTile: this.selectedTile,
                    selectedTileIndex: this.selectedTileIndex,
                    selectedOriginalPosition: this.selectedOriginalPosition,
                    suggestedMove: this.suggestedMove,
                    moveHistory: [...this.moveHistory],
                    gameEnded: this.gameEnded,
                    isDrafting: this.isDrafting
                };
                
                // Enter analysis mode
                this.isAnalysisMode = true;
                this.analysisMoveHistory = []; // Clear analysis history
                this.gameEnded = false; // Allow moves even if game was ended
                
                // Update UI
                document.getElementById('analysisModeIndicator').style.display = 'block';
                document.getElementById('analysisModeBtn').style.display = 'none';
                document.getElementById('exitAnalysisBtn').style.display = 'inline-block';
                document.querySelector('.game-container').classList.add('analysis-mode');
                
                // Add analysis-score class to score displays
                document.getElementById('player1Score').classList.add('analysis-score');
                document.getElementById('player2Score').classList.add('analysis-score');
                
                // Hide other controls during analysis
                document.getElementById('changeTileSetBtn').style.display = 'none';
                document.getElementById('draftModeBtn').style.display = 'none';
                document.getElementById('newGameBtn').style.display = 'none';
                
                this.showMessage('Analysis Mode: Explore legal moves (turn order enforced)', 'success');
                this.updateTileDisplay();
                this.updatePanelHighlight();
            }

            exitAnalysisMode() {
                // Restore complete game state directly (no confirmation needed)
                if (this.preAnalysisState) {
                    this.board = this.preAnalysisState.board;
                    this.currentPlayer = this.preAnalysisState.currentPlayer;
                    this.player1Tiles = this.preAnalysisState.player1Tiles;
                    this.player2Tiles = this.preAnalysisState.player2Tiles;
                    this.player1OriginalTiles = this.preAnalysisState.player1OriginalTiles;
                    this.player2OriginalTiles = this.preAnalysisState.player2OriginalTiles;
                    this.player1UsedPositions = this.preAnalysisState.player1UsedPositions;
                    this.player2UsedPositions = this.preAnalysisState.player2UsedPositions;
                    this.selectedTile = this.preAnalysisState.selectedTile;
                    this.selectedTileIndex = this.preAnalysisState.selectedTileIndex;
                    this.selectedOriginalPosition = this.preAnalysisState.selectedOriginalPosition;
                    this.suggestedMove = this.preAnalysisState.suggestedMove;
                    this.moveHistory = this.preAnalysisState.moveHistory;
                    this.gameEnded = this.preAnalysisState.gameEnded;
                    this.isDrafting = this.preAnalysisState.isDrafting;
                    
                    this.preAnalysisState = null;
                }
                
                // Exit analysis mode
                this.isAnalysisMode = false;
                
                // Update UI
                document.getElementById('analysisModeIndicator').style.display = 'none';
                document.getElementById('analysisModeBtn').style.display = 'inline-block';
                document.getElementById('exitAnalysisBtn').style.display = 'none';
                document.querySelector('.game-container').classList.remove('analysis-mode');
                
                // Remove analysis-score class from score displays
                document.getElementById('player1Score').classList.remove('analysis-score');
                document.getElementById('player2Score').classList.remove('analysis-score');
                
                // Show other controls again
                document.getElementById('changeTileSetBtn').style.display = 'inline-block';
                document.getElementById('draftModeBtn').style.display = 'inline-block';
                document.getElementById('newGameBtn').style.display = 'inline-block';
                
                // Redraw everything
                this.init();
                this.updatePanelHighlight();
                this.showMessage('Exited Analysis Mode - Game state restored', '');
            }

            showMessage(text, type) {
                // Update desktop message
                const messageEl = document.getElementById('message');
                messageEl.textContent = text;
                messageEl.className = 'message';
                if (type) {
                    messageEl.classList.add(type);
                }

            }
        }

        // Initialize game
        const game = new Game();
        game.updatePanelHighlight();
        

        // Rules modal functions
        function showRules() {
            document.getElementById('rulesModal').style.display = 'flex';
        }

        function hideRules() {
            document.getElementById('rulesModal').style.display = 'none';
        }

        function showCredits() {
            document.getElementById('creditsModal').style.display = 'block';
        }

        function hideCredits() {
            document.getElementById('creditsModal').style.display = 'none';
        }


        function showTileSetModal() {
            if (game.moveHistory.length > 0) {
                game.showMessage('Cannot change tile set after moves have been made!', 'error');
                return;
            }
            document.getElementById('tileSetModal').style.display = 'flex';
        }

        function hideTileSetModal() {
            document.getElementById('tileSetModal').style.display = 'none';
        }

        function selectTileSet(setName) {
            game.changeTileSet(setName);
            hideTileSetModal();
        }

        function showDraftModal() {
            if (game.moveHistory.length > 0) {
                game.showMessage('Cannot start draft after moves have been made!', 'error');
                return;
            }
            document.getElementById('draftModal').style.display = 'flex';
        }

        function hideDraftModal() {
            document.getElementById('draftModal').style.display = 'none';
        }

        function startDraft(poolType) {
            hideDraftModal();
            game.startDraft(poolType);
        }

        function cancelDraft() {
            game.cancelDraft();
        }

        function rerollDraftPool() {
            game.rerollDraftPool();
        }

        // Close rules modal when clicking outside the content
        document.getElementById('rulesModal').addEventListener('click', function(e) {
            if (e.target === this) {
                hideRules();
            }
        });

        document.getElementById('tileSetModal').addEventListener('click', function(e) {
            if (e.target === this) {
                hideTileSetModal();
            }
        });

        document.getElementById('draftModal').addEventListener('click', function(e) {
            if (e.target === this) {
                hideDraftModal();
            }
        });

        document.getElementById('draftSelectionModal').addEventListener('click', function(e) {
            if (e.target === this) {
                // Don't auto-close during draft selection to prevent accidental cancellation
            }
        });
    </script>

</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HEXUKI Mobile Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            /* Mobile touch optimizations */
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        body {
            background: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            /* Mobile performance optimizations */
            -webkit-overflow-scrolling: touch;
            overflow-x: hidden;
        }

        /* Phone simulator frame */
        .phone-frame {
            width: 375px;
            height: 812px;
            background: #000;
            border-radius: 40px;
            padding: 10px;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
        }

        .phone-screen {
            width: 100%;
            height: 100%;
            background: white;
            border-radius: 30px;
            overflow: hidden;
            position: relative;
        }

        /* Main app container */
        .mobile-app {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #f8f8f8;
        }

        /* Score display */
        .score-bar {
            width: 100%;
            height: 40px;
            background: #333;
            color: white;
            display: flex;
            justify-content: space-around;
            align-items: center;
            font-size: 16px;
            font-weight: 600;
        }

        .score-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .score-item.player1 { color: #ff6b6b; }
        .score-item.player2 { color: #4dabf7; }

        /* Top menu */
        .top-menu {
            width: 100%;
            height: 35px;
            background: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 0 10px;
        }

        .menu-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #34495e;
            color: white;
            min-width: 70px;
        }

        .menu-btn:hover {
            background: #4a5f7a;
        }

        .menu-btn:active {
            transform: scale(0.95);
        }

        .menu-btn:disabled {
            background: #95a5a6;
            color: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.6;
        }

        /* Player 1 tiles (top) */
        .player1-tiles {
            width: 100%;
            height: 45px;
            background: #fff;
            border-bottom: 1px solid #ddd;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1px;
            padding: 0 8px;
            margin-bottom: 2px;
            transition: all 0.3s ease;
        }

        .player1-tiles.active {
            background: #ffe6e6;
            border-left: 4px solid #c0392b;
            border-right: 4px solid #c0392b;
            border-bottom: 2px solid #c0392b;
        }

        /* Game board area */
        .board-container {
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 0;
            position: relative;
        }

        /* Player 2 tiles (bottom) */
        .player2-tiles {
            width: 100%;
            height: 45px;
            background: #fff;
            border-top: 1px solid #ddd;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1px;
            padding: 0 8px;
            margin-top: -18px;
            position: relative;
            z-index: 5;
            transition: all 0.3s ease;
        }

        .player2-tiles.active {
            background: #e6f3ff;
            border-left: 4px solid #2980b9;
            border-right: 4px solid #2980b9;
            border-top: 2px solid #2980b9;
        }

        /* Tile styling */
        .tile {
            width: 39px;
            height: 39px;
            background: white;
            border: 2px solid #333;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 19px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            /* Mobile touch optimizations */
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(0,0,0,0.1);
        }

        .tile:active {
            transform: scale(0.95);
        }

        .tile.selected {
            transform: scale(1.15);
            box-shadow: 0 0 15px rgba(0,0,0,0.4);
            z-index: 10;
        }

        .tile.used {
            opacity: 0.3;
            cursor: not-allowed;
            transform: scale(0.9);
        }

        .tile.chain-violation {
            background: #ffebee !important;
            border-color: #8b0000 !important;
            opacity: 0.6;
            cursor: not-allowed;
        }

        .player1-tiles .tile {
            color: #c0392b;
            border-color: #c0392b;
        }

        .player1-tiles .tile.selected {
            background: #c0392b;
            color: white;
        }

        .player2-tiles .tile {
            color: #2980b9;
            border-color: #2980b9;
        }

        .player2-tiles .tile.selected {
            background: #2980b9;
            color: white;
        }

        /* SVG Board */
        .hex-board-svg {
            width: 100%;
            max-width: none;
            height: auto;
            /* Mobile SVG optimizations */
            shape-rendering: optimizeSpeed;
            text-rendering: optimizeSpeed;
        }

        /* Hex styling - matching web version exactly */
        .hex {
            fill: #f8f9fa;
            stroke: #333;
            stroke-width: 1;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .hex.occupied {
            fill: #ffd700;
            cursor: default;
        }

        .hex.valid-move {
            fill: #d4edda;
            stroke: #28a745;
            stroke-width: 2;
        }

        .hex.invalid-move {
            fill: #fdf2f2;
        }

        .hex.chain-violation-hex {
            fill: #fceaea;
        }

        .hex-text {
            font-size: 46px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            fill: #333;
            opacity: 0;
            transform: scale(0.5);
        }

        .hex-text.animate-in.player1 {
            animation: tilePlace 0.4s ease-out forwards !important;
            z-index: 1000;
        }

        .hex-text.animate-in.player2 {
            animation: tilePlaceFromBottom 0.4s ease-out forwards !important;
            z-index: 1000;
        }

        .hex-text.animate-in {
            animation: tilePlace 0.4s ease-out forwards;
        }

        .hex-text.no-animation {
            opacity: 1;
            transform: scale(1);
        }

        @keyframes tilePlace {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(-100px);
            }
            50% {
                opacity: 1;
                transform: scale(1.1) translateY(-20px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        @keyframes tilePlaceFromBottom {
            0% {
                opacity: 0;
                transform: scale(0.5) translateY(200px);
            }
            50% {
                opacity: 1;
                transform: scale(1.1) translateY(40px);
            }
            100% {
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .chain-line {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            opacity: 0.8;
            animation: drawLine 1.2s ease-in-out forwards;
        }

        @keyframes drawLine {
            0% {
                stroke-dashoffset: 1000;
                opacity: 0.8;
            }
            70% {
                stroke-dashoffset: 0;
                opacity: 0.8;
            }
            100% {
                stroke-dashoffset: 0;
                opacity: 0;
            }
        }

        .hex-text.player1 {
            fill: #c0392b;
        }

        .hex-text.player2 {
            fill: #2980b9;
        }

        .question-mark {
            font-size: 55px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            fill: #333;
        }

        .invalid-x {
            font-size: 36px;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            fill: #d63031;
            opacity: 0.25;
        }

        /* Size selector */
        .size-selector {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 100;
        }

        .size-selector label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: bold;
        }

        .size-selector select {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ccc;
            font-size: 14px;
        }

        /* Notification system */
        .notification {
            position: fixed;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: calc(100% - 40px);
            max-width: 355px;
            padding: 12px;
            font-size: 14px;
            font-weight: 500;
            text-align: center;
            z-index: 1000;
            border-radius: 0 0 8px 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            transform: translateX(-50%) translateY(-100%);
        }

        .notification.show {
            transform: translateX(-50%) translateY(0);
        }

        .notification.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .notification.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .notification.info {
            background: #cce7ff;
            color: #004085;
            border: 1px solid #b0d4f1;
        }

        /* Turn indicator */
        .turn-indicator {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            font-weight: 600;
        }

        .turn-indicator.player1 { color: #c0392b; }
        .turn-indicator.player2 { color: #2980b9; }

        /* Bottom controls */
        .bottom-controls {
            width: 100%;
            height: 50px;
            background: white;
            border-top: 1px solid #ddd;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 0 20px;
        }

        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 80px;
            /* Mobile touch optimizations */
            touch-action: manipulation;
            -webkit-tap-highlight-color: rgba(255,255,255,0.2);
        }

        .control-btn.undo {
            background: #95a5a6;
            color: white;
        }

        .control-btn.undo:hover {
            background: #7f8c8d;
        }

        .control-btn.undo:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .control-btn.reset {
            background: #e74c3c;
            color: white;
        }

        .control-btn.reset:hover {
            background: #c0392b;
        }

        .control-btn.reset:disabled {
            background: #f1948a;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .control-btn:active {
            transform: scale(0.95);
        }

        /* Confirmation modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: white;
            border-radius: 12px;
            padding: 24px;
            max-width: 300px;
            width: 90%;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal.large {
            max-width: 350px;
            text-align: left;
        }

        .modal.large h3 {
            text-align: center;
            margin-bottom: 20px;
        }

        .modal.large .close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 24px;
            color: #666;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .modal.large .close-btn:hover {
            color: #333;
        }

        .modal.large {
            position: relative;
        }

        .rules-content {
            font-size: 14px;
            line-height: 1.4;
            color: #333;
        }

        .rules-content h4 {
            color: #2c3e50;
            margin: 16px 0 8px 0;
            font-size: 15px;
        }

        .rules-content ul {
            margin: 8px 0;
            padding-left: 20px;
        }

        .rules-content li {
            margin: 4px 0;
        }

        .tile-sets-content {
            font-size: 14px;
            line-height: 1.4;
            color: #333;
        }

        .tile-set-option {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tile-set-option:hover {
            border-color: #3498db;
            background: #ebf3fd;
        }

        .tile-set-option.active {
            border-color: #2ecc71;
            background: #d5f4e6;
        }

        .tile-set-name {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .tile-set-tiles {
            font-family: monospace;
            color: #666;
            font-size: 13px;
        }

        /* Scoring example styles for mobile */
        .scoring-example {
            margin: 20px 0;
            text-align: center;
        }

        .example-board {
            width: 100%;
            max-width: 300px;
            height: auto;
            margin: 15px auto;
        }

        .example-hex {
            fill: #f8f9fa;
            stroke: #333;
            stroke-width: 1;
        }

        .example-hex.filled {
            fill: #ffd700;
        }

        .example-text {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            font-size: 18px;
            font-weight: 600;
            text-anchor: middle;
            dominant-baseline: central;
        }

        .example-text.red {
            fill: #c0392b;
        }

        .example-text.blue {
            fill: #2980b9;
        }

        .example-text.neutral {
            fill: #333;
        }

        .score-breakdown {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin: 15px 0;
            font-size: 12px;
        }

        .chain-calc {
            margin: 4px 0;
            padding: 4px 6px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 11px;
        }

        .chain-calc.red {
            background: #fdf6f6;
            border-left: 3px solid #c0392b;
        }

        .chain-calc.blue {
            background: #f6f8fd;
            border-left: 3px solid #2980b9;
        }

        .total-score {
            font-size: 13px;
            font-weight: bold;
            margin-top: 8px;
            padding: 6px;
            border-radius: 6px;
            text-align: center;
        }

        .total-score.red {
            background: #fdf6f6;
            color: #c0392b;
        }

        .total-score.blue {
            background: #f6f8fd;
            color: #2980b9;
        }

        .modal h3 {
            margin: 0 0 16px 0;
            color: #e74c3c;
            font-size: 18px;
            font-weight: 600;
        }

        .modal p {
            margin: 0 0 24px 0;
            color: #666;
            font-size: 14px;
            line-height: 1.4;
        }

        .modal-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
        }

        .modal-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 80px;
        }

        .modal-btn.confirm {
            background: #e74c3c;
            color: white;
        }

        .modal-btn.confirm:hover {
            background: #c0392b;
        }

        .modal-btn.cancel {
            background: #95a5a6;
            color: white;
        }

        .modal-btn.cancel:hover {
            background: #7f8c8d;
        }

        .modal-btn:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <!-- Phone size selector -->
    <div class="size-selector">
        <label>Phone Size:</label>
        <select id="phoneSize" onchange="changePhoneSize()">
            <option value="375,812">iPhone 12/13/14 (375×812)</option>
            <option value="375,667">iPhone 13 Mini (375×667)</option>
            <option value="360,800">Android Small (360×800)</option>
            <option value="320,568">iPhone SE (320×568)</option>
            <option value="414,896">iPhone Plus (414×896)</option>
            <option value="390,844">iPhone 14 Pro (390×844)</option>
        </select>
    </div>

    <!-- Phone simulator -->
    <div class="phone-frame" id="phoneFrame">
        <div class="phone-screen">
            <!-- Notification -->
            <div class="notification" id="notification"></div>
            
            <div class="mobile-app">
                <!-- Top menu -->
                <div class="top-menu">
                    <button class="menu-btn" onclick="showRules()">Rules</button>
                    <button class="menu-btn" id="tileSetsBtn" onclick="showTileSets()">Tile Sets</button>
                </div>

                <!-- Score bar -->
                <div class="score-bar">
                    <div class="score-item player1">
                        <span>P1:</span>
                        <span id="player1Score">0</span>
                    </div>
                    <div class="score-item player2">
                        <span>P2:</span>
                        <span id="player2Score">0</span>
                    </div>
                </div>

                <!-- Turn indicator -->
                <div class="turn-indicator player1" id="turnIndicator">Player 1's Turn</div>

                <!-- Player 1 tiles (top) -->
                <div class="player1-tiles" id="player1Tiles">
                    <!-- Tiles generated dynamically -->
                </div>

                <!-- Game board -->
                <div class="board-container">
                    <svg class="hex-board-svg" viewBox="-15 15 430 600" xmlns="http://www.w3.org/2000/svg" id="gameBoard">
                        <!-- Hexagons will be drawn here -->
                    </svg>
                </div>

                <!-- Player 2 tiles (bottom) -->
                <div class="player2-tiles" id="player2Tiles">
                    <!-- Tiles generated dynamically -->
                </div>

                <!-- Bottom controls -->
                <div class="bottom-controls">
                    <button class="control-btn undo" id="undoBtn" onclick="undoMove()">Undo</button>
                    <button class="control-btn reset" id="resetBtn" onclick="showResetConfirmation()">Reset Game</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal -->
    <div class="modal-overlay" id="resetModal">
        <div class="modal">
            <h3>Reset Game?</h3>
            <p>This will clear all moves and start a new game. This action cannot be undone.</p>
            <div class="modal-buttons">
                <button class="modal-btn cancel" onclick="hideResetConfirmation()">Cancel</button>
                <button class="modal-btn confirm" onclick="confirmReset()">Reset Game</button>
            </div>
        </div>
    </div>

    <!-- Rules Modal -->
    <div class="modal-overlay" id="rulesModal">
        <div class="modal large">
            <button class="close-btn" onclick="hideRules()">&times;</button>
            <h3>Rules</h3>
            <div class="rules-content">
                <h4>Objective</h4>
                <p>Place numbered tiles on the hexagonal board to score more points than your opponent through diagonal chain multiplication.</p>
                
                <h4>Setup</h4>
                <ul>
                    <li>Each player starts with 9 tiles with a number value.</li>
                    <li>The center hex starts with a neutral "1".</li>
                    <li>Player 1 places any tile on the board to start the game. Players alternate placing 1 tile until all tiles are placed.</li>
                </ul>
                
                <h4>Placement Rules</h4>
                <ul>
                    <li><strong>Adjacent Rule:</strong> New tiles must be placed next to existing tiles.</li>
                    <li><strong>Chain Length Rule:</strong> The longest chain can be at most 1 longer than the second longest chain.
                        <ul>
                            <li>A chain is any number of consecutive tiles in a straight line.</li>
                        </ul>
                    </li>
                </ul>
                
                <h4>Scoring Example</h4>
                <p><strong>Player 1 (Red):</strong> 5 diagonal chains going down-right<br>
                <strong>Player 2 (Blue):</strong> 5 diagonal chains going down-left</p>
                
                <div class="scoring-example">
                    <h5>Sample End Game:</h5>
                    <svg class="example-board" width="300" height="288" viewBox="0 0 500 480">
                        <!-- Hex 0 -->
                        <polygon class="example-hex filled" points="275,70 264,50 242,50 231,70 242,90 264,90" />
                        <text class="example-text blue" x="253" y="70">6</text>
                        
                        <!-- Hex 1 -->
                        <polygon class="example-hex filled" points="214,100 203,80 181,80 170,100 181,120 203,120" />
                        <text class="example-text red" x="192" y="100">4</text>
                        
                        <!-- Hex 2 -->
                        <polygon class="example-hex filled" points="336,100 325,80 303,80 292,100 303,120 325,120" />
                        <text class="example-text blue" x="314" y="100">8</text>
                        
                        <!-- Hex 3 -->
                        <polygon class="example-hex filled" points="153,130 142,110 120,110 109,130 120,150 142,150" />
                        <text class="example-text red" x="131" y="130">7</text>
                        
                        <!-- Hex 4 -->
                        <polygon class="example-hex filled" points="275,130 264,110 242,110 231,130 242,150 264,150" />
                        <text class="example-text red" x="253" y="130">1</text>
                        
                        <!-- Hex 5 -->
                        <polygon class="example-hex filled" points="397,130 386,110 364,110 353,130 364,150 386,150" />
                        <text class="example-text blue" x="375" y="130">9</text>
                        
                        <!-- Hex 6 -->
                        <polygon class="example-hex filled" points="214,160 203,140 181,140 170,160 181,180 203,180" />
                        <text class="example-text red" x="192" y="160">3</text>
                        
                        <!-- Hex 7 -->
                        <polygon class="example-hex filled" points="336,160 325,140 303,140 292,160 303,180 325,180" />
                        <text class="example-text blue" x="314" y="160">2</text>
                        
                        <!-- Hex 8 -->
                        <polygon class="example-hex filled" points="153,190 142,170 120,170 109,190 120,210 142,210" />
                        <text class="example-text red" x="131" y="190">9</text>
                        
                        <!-- Hex 9 - center -->
                        <polygon class="example-hex filled" points="275,190 264,170 242,170 231,190 242,210 264,210" />
                        <text class="example-text neutral" x="253" y="190">1</text>
                        
                        <!-- Hex 10 -->
                        <polygon class="example-hex filled" points="397,190 386,170 364,170 353,190 364,210 386,210" />
                        <text class="example-text blue" x="375" y="190">5</text>
                        
                        <!-- Hex 11 -->
                        <polygon class="example-hex filled" points="214,220 203,200 181,200 170,220 181,240 203,240" />
                        <text class="example-text blue" x="192" y="220">1</text>
                        
                        <!-- Hex 12 -->
                        <polygon class="example-hex filled" points="336,220 325,200 303,200 292,220 303,240 325,240" />
                        <text class="example-text blue" x="314" y="220">7</text>
                        
                        <!-- Hex 13 -->
                        <polygon class="example-hex filled" points="153,250 142,230 120,230 109,250 120,270 142,270" />
                        <text class="example-text red" x="131" y="250">8</text>
                        
                        <!-- Hex 14 -->
                        <polygon class="example-hex filled" points="275,250 264,230 242,230 231,250 242,270 264,270" />
                        <text class="example-text blue" x="253" y="250">3</text>
                        
                        <!-- Hex 15 -->
                        <polygon class="example-hex filled" points="397,250 386,230 364,230 353,250 364,270 386,270" />
                        <text class="example-text red" x="375" y="250">6</text>
                        
                        <!-- Hex 16 -->
                        <polygon class="example-hex filled" points="214,280 203,260 181,260 170,280 181,300 203,300" />
                        <text class="example-text blue" x="192" y="280">4</text>
                        
                        <!-- Hex 17 -->
                        <polygon class="example-hex filled" points="336,280 325,260 303,260 292,280 303,300 325,300" />
                        <text class="example-text red" x="314" y="280">2</text>
                        
                        <!-- Hex 18 -->
                        <polygon class="example-hex filled" points="275,310 264,290 242,290 231,310 242,330 264,330" />
                        <text class="example-text red" x="253" y="310">5</text>
                        
                        <!-- Player 1 (Red) scoring chains - DOWNRIGHT -->
                        <!-- Chain 1: 0-2-5 -->
                        <line x1="253" y1="70" x2="375" y2="130" stroke="#c0392b" stroke-width="2" opacity="0.6" />
                        
                        <!-- Chain 2: 1-4-7-10 -->
                        <line x1="192" y1="100" x2="375" y2="190" stroke="#c0392b" stroke-width="2" opacity="0.6" />
                        
                        <!-- Chain 3: 3-6-9-12-15 -->
                        <line x1="131" y1="130" x2="375" y2="250" stroke="#c0392b" stroke-width="2" opacity="0.6" />
                        
                        <!-- Chain 4: 8-11-14-17 -->
                        <line x1="131" y1="190" x2="314" y2="280" stroke="#c0392b" stroke-width="2" opacity="0.6" />
                        
                        <!-- Chain 5: 13-16-18 -->
                        <line x1="131" y1="250" x2="253" y2="310" stroke="#c0392b" stroke-width="2" opacity="0.6" />
                        
                        <!-- Player 2 (Blue) scoring chains - DOWNLEFT -->
                        <!-- Chain 1: 0-1-3 -->
                        <line x1="253" y1="70" x2="131" y2="130" stroke="#2980b9" stroke-width="2" opacity="0.6" />
                        
                        <!-- Chain 2: 2-4-6-8 -->
                        <line x1="314" y1="100" x2="131" y2="190" stroke="#2980b9" stroke-width="2" opacity="0.6" />
                        
                        <!-- Chain 3: 5-7-9-11-13 -->
                        <line x1="375" y1="130" x2="131" y2="250" stroke="#2980b9" stroke-width="2" opacity="0.6" />
                        
                        <!-- Chain 4: 10-12-14-16 -->
                        <line x1="375" y1="190" x2="192" y2="280" stroke="#2980b9" stroke-width="2" opacity="0.6" />
                        
                        <!-- Chain 5: 15-17-18 -->
                        <line x1="375" y1="250" x2="253" y2="310" stroke="#2980b9" stroke-width="2" opacity="0.6" />
                    </svg>
                    
                    <div class="score-breakdown">
                        <h5>Player 1 (Red) DOWNRIGHT:</h5>
                        <div class="chain-calc red">Chain 1: 6 × 8 × 9 = 432</div>
                        <div class="chain-calc red">Chain 2: 4 × 1 × 2 × 5 = 40</div>
                        <div class="chain-calc red">Chain 3: 7 × 3 × 1 × 7 × 6 = 882</div>
                        <div class="chain-calc red">Chain 4: 9 × 1 × 3 × 2 = 54</div>
                        <div class="chain-calc red">Chain 5: 8 × 4 × 5 = 160</div>
                        <div class="total-score red">Player 1 Total: 1,568</div>
                        
                        <h5>Player 2 (Blue) DOWNLEFT:</h5>
                        <div class="chain-calc blue">Chain 1: 6 × 4 × 7 = 168</div>
                        <div class="chain-calc blue">Chain 2: 8 × 1 × 3 × 9 = 216</div>
                        <div class="chain-calc blue">Chain 3: 9 × 2 × 1 × 1 × 8 = 144</div>
                        <div class="chain-calc blue">Chain 4: 5 × 7 × 3 × 4 = 420</div>
                        <div class="chain-calc blue">Chain 5: 6 × 2 × 5 = 60</div>
                        <div class="total-score blue">Player 2 Total: 1,008</div>
                    </div>
                </div>
                
                <h4>Scoring Rules</h4>
                <ul>
                    <li>Each chain multiplies all tile values along that diagonal.</li>
                    <li>Add up all 5 chain products for your total score.</li>
                    <li>Don't be annoying by mirroring your opponent's moves exactly. If a tie happens naturally then it is a fair draw.</li>
                </ul>
                
                <div style="text-align: center; margin-top: 30px;">
                    <button class="control-btn" onclick="hideRules()" style="background: #2ecc71; color: white; font-size: 18px; padding: 15px 40px;">Got it!</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Tile Sets Modal -->
    <div class="modal-overlay" id="tileSetsModal">
        <div class="modal large">
            <button class="close-btn" onclick="hideTileSets()">&times;</button>
            <h3>Tile Sets</h3>
            <div class="tile-sets-content" id="tileSetsContent">
                <!-- Tile set options will be generated here -->
            </div>
        </div>
    </div>

    <script>
        // Game state
        const gameState = {
            currentPlayer: 1,
            selectedTile: null,
            board: Array(19).fill(null),
            player1Tiles: [1,2,3,4,5,6,7,8,9],
            player2Tiles: [1,2,3,4,5,6,7,8,9],
            player1Used: new Set(),
            player2Used: new Set(),
            hexSize: 52,
            centerX: 200,
            centerY: 300,
            moveHistory: [],
            gameEnded: false,
            currentTileSet: 'standard',
            lastPlacedTile: null
        };

        // Tile sets
        const tileSets = {
            standard: [1,2,3,4,5,6,7,8,9],
            low: [1,1,2,2,3,3,4,4,5],
            high: [5,6,6,7,7,8,8,9,9],
            balanced: [2,3,4,4,5,5,6,6,7],
            fibonacci: [1,1,2,3,3,5,5,8,8],
            powers: [1,1,1,2,2,4,4,8,8],
            random_same: null, // Same random set for both players
            random_different: null // Different random sets for each player
        };

        // Generate a random tile set
        function generateRandomTileSet() {
            const tiles = [];
            for (let i = 0; i < 9; i++) {
                tiles.push(Math.floor(Math.random() * 9) + 1);
            }
            return tiles;
        }

        // Get hex position coordinates for drawing lines
        function getHexPosition(hexId) {
            const hexWidth = gameState.hexSize * 2;
            const hexHeight = Math.sqrt(3) * gameState.hexSize;
            
            const positions = [
                {id: 0, x: gameState.centerX, y: gameState.centerY - hexHeight * 2},
                {id: 1, x: gameState.centerX - hexWidth * 0.75, y: gameState.centerY - hexHeight * 1.5},
                {id: 2, x: gameState.centerX + hexWidth * 0.75, y: gameState.centerY - hexHeight * 1.5},
                {id: 3, x: gameState.centerX - hexWidth * 1.5, y: gameState.centerY - hexHeight},
                {id: 4, x: gameState.centerX, y: gameState.centerY - hexHeight},
                {id: 5, x: gameState.centerX + hexWidth * 1.5, y: gameState.centerY - hexHeight},
                {id: 6, x: gameState.centerX - hexWidth * 0.75, y: gameState.centerY - hexHeight * 0.5},
                {id: 7, x: gameState.centerX + hexWidth * 0.75, y: gameState.centerY - hexHeight * 0.5},
                {id: 8, x: gameState.centerX - hexWidth * 1.5, y: gameState.centerY},
                {id: 9, x: gameState.centerX, y: gameState.centerY},
                {id: 10, x: gameState.centerX + hexWidth * 1.5, y: gameState.centerY},
                {id: 11, x: gameState.centerX - hexWidth * 0.75, y: gameState.centerY + hexHeight * 0.5},
                {id: 12, x: gameState.centerX + hexWidth * 0.75, y: gameState.centerY + hexHeight * 0.5},
                {id: 13, x: gameState.centerX - hexWidth * 1.5, y: gameState.centerY + hexHeight},
                {id: 14, x: gameState.centerX, y: gameState.centerY + hexHeight},
                {id: 15, x: gameState.centerX + hexWidth * 1.5, y: gameState.centerY + hexHeight},
                {id: 16, x: gameState.centerX - hexWidth * 0.75, y: gameState.centerY + hexHeight * 1.5},
                {id: 17, x: gameState.centerX + hexWidth * 0.75, y: gameState.centerY + hexHeight * 1.5},
                {id: 18, x: gameState.centerX, y: gameState.centerY + hexHeight * 2}
            ];
            
            return positions.find(pos => pos.id === hexId);
        }

        // Animate chain lines for the placed tile
        function animateChainLines(placedHexId) {
            const svg = document.getElementById('gameBoard');
            
            // Define the diagonal chains
            const player1Chains = [
                [0, 2, 5],      // Chain 1: A→C→F
                [1, 4, 7, 10],  // Chain 2: B→E→H→K
                [3, 6, 9, 12, 15], // Chain 3: D→G→J→M→P
                [8, 11, 14, 17], // Chain 4: I→L→O→R
                [13, 16, 18]    // Chain 5: N→Q→S
            ];
            
            const player2Chains = [
                [0, 1, 3],      // Chain 1: A→B→D
                [2, 4, 6, 8],   // Chain 2: C→E→G→I
                [5, 7, 9, 11, 13], // Chain 3: F→H→J→L→N
                [10, 12, 14, 16], // Chain 4: K→M→O→Q
                [15, 17, 18]    // Chain 5: P→R→S
            ];
            
            // Find which chains contain the placed hex
            const chainsToAnimate = [];
            
            player1Chains.forEach((chain, index) => {
                if (chain.includes(placedHexId)) {
                    chainsToAnimate.push({chain, player: 1, color: '#c0392b'});
                }
            });
            
            player2Chains.forEach((chain, index) => {
                if (chain.includes(placedHexId)) {
                    chainsToAnimate.push({chain, player: 2, color: '#2980b9'});
                }
            });
            
            // Draw and animate lines for each affected chain
            chainsToAnimate.forEach(({chain, player, color}) => {
                // Draw a single line spanning the entire chain
                if (chain.length > 1) {
                    const firstPos = getHexPosition(chain[0]);
                    const lastPos = getHexPosition(chain[chain.length - 1]);
                    
                    if (firstPos && lastPos) {
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', firstPos.x);
                        line.setAttribute('y1', firstPos.y);
                        line.setAttribute('x2', lastPos.x);
                        line.setAttribute('y2', lastPos.y);
                        line.setAttribute('stroke', color);
                        line.setAttribute('stroke-width', '4');
                        line.setAttribute('class', 'chain-line');
                        
                        svg.appendChild(line);
                        
                        // Remove line after animation
                        setTimeout(() => {
                            if (line.parentNode) {
                                line.parentNode.removeChild(line);
                            }
                        }, 1200);
                    }
                }
            });
        }

        // Board positions with row/col for adjacency
        const boardLayout = [
            {id: 0, row: 0, col: 2},
            {id: 1, row: 1, col: 1},
            {id: 2, row: 1, col: 3},
            {id: 3, row: 2, col: 0},
            {id: 4, row: 2, col: 2},
            {id: 5, row: 2, col: 4},
            {id: 6, row: 3, col: 1},
            {id: 7, row: 3, col: 3},
            {id: 8, row: 4, col: 0},
            {id: 9, row: 4, col: 2},
            {id: 10, row: 4, col: 4},
            {id: 11, row: 5, col: 1},
            {id: 12, row: 5, col: 3},
            {id: 13, row: 6, col: 0},
            {id: 14, row: 6, col: 2},
            {id: 15, row: 6, col: 4},
            {id: 16, row: 7, col: 1},
            {id: 17, row: 7, col: 3},
            {id: 18, row: 8, col: 2}
        ];

        function changePhoneSize() {
            const select = document.getElementById('phoneSize');
            const [width, height] = select.value.split(',');
            const frame = document.getElementById('phoneFrame');
            frame.style.width = width + 'px';
            frame.style.height = height + 'px';
        }

        // Notification system
        let notificationTimeout = null;

        function showMessage(text, type = 'info', duration = 3000) {
            const notification = document.getElementById('notification');
            
            // Clear any existing timeout
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
            }
            
            // Set message and type
            notification.textContent = text;
            notification.className = `notification ${type}`;
            
            // Show notification
            setTimeout(() => {
                notification.classList.add('show');
            }, 10);
            
            // Auto-hide after duration
            notificationTimeout = setTimeout(() => {
                hideMessage();
            }, duration);
        }

        function hideMessage() {
            const notification = document.getElementById('notification');
            notification.classList.remove('show');
            
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
                notificationTimeout = null;
            }
        }

        // Get adjacent hexes using row/col offsets
        function getAdjacentHexes(hexId) {
            const hex = boardLayout[hexId];
            const adjacent = [];
            
            const directions = [
                {dr: -2, dc: 0},   // UP
                {dr: -1, dc: 1},   // UPRIGHT
                {dr: 1, dc: 1},    // DOWNRIGHT
                {dr: 2, dc: 0},    // DOWN
                {dr: 1, dc: -1},   // DOWNLEFT
                {dr: -1, dc: -1}   // UPLEFT
            ];

            directions.forEach(({dr, dc}) => {
                const adjHex = boardLayout.find(h => 
                    h.row === hex.row + dr && h.col === hex.col + dc
                );
                if (adjHex) {
                    adjacent.push(adjHex.id);
                }
            });

            return adjacent;
        }

        // Check chain length constraint (matching web version exactly)
        function checkChainLengthConstraint(hexId) {
            // Make a test board with the proposed move
            const testBoard = [...gameState.board];
            testBoard[hexId] = { value: 1, player: gameState.currentPlayer };
            
            // Get chain lengths AFTER the hypothetical placement
            const newChainLengths = getFirstAndSecondChainLengths(testBoard);
            
            // Rule: longest chain can be at most 1 longer than second longest
            if (newChainLengths.first > newChainLengths.second + 1) {
                return false;
            }
            
            return true;
        }

        function getFirstAndSecondChainLengths(boardState) {
            const allChainLengths = getAllChainLengthsForBoard(boardState);
            let first = 0, second = 0;
            
            allChainLengths.forEach(length => {
                if (length > first) {
                    second = first;
                    first = length;
                } else if (length > second) {
                    second = length;
                }
            });
            
            return { first, second };
        }

        function getAllChainLengthsForBoard(boardState) {
            const chainLengths = [];
            
            // All possible chain starters and directions (from web version)
            const chainStarters = [
                {start: 0, dir: {dr: 1, dc: -1}}, // DOWNLEFT
                {start: 0, dir: {dr: 2, dc: 0}},  // DOWN
                {start: 0, dir: {dr: 1, dc: 1}},  // DOWNRIGHT
                {start: 1, dir: {dr: 2, dc: 0}},  // DOWN
                {start: 1, dir: {dr: 1, dc: 1}},  // DOWNRIGHT
                {start: 2, dir: {dr: 1, dc: -1}}, // DOWNLEFT
                {start: 2, dir: {dr: 2, dc: 0}},  // DOWN
                {start: 3, dir: {dr: 2, dc: 0}},  // DOWN
                {start: 3, dir: {dr: 1, dc: 1}},  // DOWNRIGHT
                {start: 5, dir: {dr: 1, dc: -1}}, // DOWNLEFT
                {start: 5, dir: {dr: 2, dc: 0}},  // DOWN
                {start: 8, dir: {dr: 1, dc: 1}},  // DOWNRIGHT
                {start: 10, dir: {dr: 1, dc: -1}}, // DOWNLEFT
                {start: 13, dir: {dr: 1, dc: 1}}, // DOWNRIGHT
                {start: 15, dir: {dr: 1, dc: -1}} // DOWNLEFT
            ];
            
            chainStarters.forEach(({start, dir}) => {
                const lengths = getChainLengthsFromStart(boardState, start, dir);
                chainLengths.push(...lengths);
            });
            
            return chainLengths;
        }

        function getChainLengthsFromStart(boardState, startId, direction) {
            const lengths = [];
            let currentLength = 0;
            let current = startId;
            
            while (current !== null) {
                const currentHex = boardLayout[current];
                if (!currentHex) break;
                
                if (boardState[current] && boardState[current].value !== null) {
                    currentLength++;
                } else if (currentLength > 0) {
                    // Hit empty cell, record current chain and reset
                    lengths.push(currentLength);
                    currentLength = 0;
                }
                
                // Move to next cell in direction
                const nextHex = boardLayout.find(h => 
                    h.row === currentHex.row + direction.dr && h.col === currentHex.col + direction.dc
                );
                current = nextHex ? nextHex.id : null;
            }
            
            // Record final chain if we ended on occupied cells
            if (currentLength > 0) {
                lengths.push(currentLength);
            }
            
            return lengths;
        }

        // Check if a move is legal
        function isMoveLegal(hexId) {
            // Check if hex is empty
            if (gameState.board[hexId] !== null) return false;
            
            // Check if adjacent to an occupied hex
            const adjacentHexes = getAdjacentHexes(hexId);
            const hasAdjacentOccupied = adjacentHexes.some(id => 
                gameState.board[id] !== null
            );
            
            if (!hasAdjacentOccupied) return false;
            
            // Check chain length constraint
            const chainOk = checkChainLengthConstraint(hexId);
            console.log(`Hex ${hexId}: adjacent=${hasAdjacentOccupied}, chainOk=${chainOk}`);
            return chainOk;
        }

        // Get all valid moves
        function getValidMoves() {
            const validMoves = [];
            
            for (let i = 0; i < 19; i++) {
                if (isMoveLegal(i)) {
                    validMoves.push(i);
                }
            }
            
            console.log('Valid moves:', validMoves);
            return validMoves;
        }

        // Check if a tile causes chain violations
        function tileWouldCauseChainViolation(tileIndex, player) {
            const validMoves = getValidMoves();
            
            // If no valid moves, can't cause violations
            if (validMoves.length === 0) return false;
            
            // Check if ALL valid moves would violate chain constraint
            for (const hexId of validMoves) {
                if (checkChainLengthConstraint(hexId)) {
                    return false; // Found at least one legal move
                }
            }
            
            return true; // All moves would violate
        }

        // Calculate scores using diagonal chains
        function calculateScores() {
            let player1Score = 0;
            let player2Score = 0;

            // Player 1 DOWNRIGHT diagonal chains
            const player1Chains = [
                [0, 2, 5],         // A-C-F
                [1, 4, 7, 10],     // B-E-H-K
                [3, 6, 9, 12, 15], // D-G-J-M-P
                [8, 11, 14, 17],   // I-L-O-R
                [13, 16, 18]       // N-Q-S
            ];

            // Player 2 DOWNLEFT diagonal chains
            const player2Chains = [
                [0, 1, 3],         // A-B-D
                [2, 4, 6, 8],      // C-E-G-I
                [5, 7, 9, 11, 13], // F-H-J-L-N
                [10, 12, 14, 16],  // K-M-O-Q
                [15, 17, 18]       // P-R-S
            ];

            // Calculate Player 1 score
            player1Chains.forEach(chain => {
                let hasAnyTiles = false;
                let lineProduct = 1;
                
                chain.forEach(hexId => {
                    const cell = gameState.board[hexId];
                    const value = (cell && cell.value !== null) ? cell.value : 1;
                    lineProduct *= value;
                    if (cell && cell.value !== null) {
                        hasAnyTiles = true;
                    }
                });
                
                if (hasAnyTiles) {
                    player1Score += lineProduct;
                }
            });

            // Calculate Player 2 score
            player2Chains.forEach(chain => {
                let hasAnyTiles = false;
                let lineProduct = 1;
                
                chain.forEach(hexId => {
                    const cell = gameState.board[hexId];
                    const value = (cell && cell.value !== null) ? cell.value : 1;
                    lineProduct *= value;
                    if (cell && cell.value !== null) {
                        hasAnyTiles = true;
                    }
                });
                
                if (hasAnyTiles) {
                    player2Score += lineProduct;
                }
            });

            return { player1: player1Score, player2: player2Score };
        }

        // Update score display
        function updateScores() {
            const scores = calculateScores();
            document.getElementById('player1Score').textContent = scores.player1;
            document.getElementById('player2Score').textContent = scores.player2;
        }

        // Draw player tiles
        function drawPlayerTiles() {
            const player1Container = document.getElementById('player1Tiles');
            const player2Container = document.getElementById('player2Tiles');
            
            // Update active player highlighting
            if (gameState.currentPlayer === 1) {
                player1Container.classList.add('active');
                player2Container.classList.remove('active');
            } else {
                player1Container.classList.remove('active');
                player2Container.classList.add('active');
            }
            
            player1Container.innerHTML = '';
            player2Container.innerHTML = '';
            
            // Player 1 tiles
            gameState.player1Tiles.forEach((value, index) => {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.textContent = value;
                tile.setAttribute('data-player', '1');
                tile.setAttribute('data-index', index);
                tile.setAttribute('data-value', value);
                
                if (gameState.player1Used.has(index)) {
                    tile.classList.add('used');
                } else {
                    // Check for chain violations
                    if (gameState.currentPlayer === 1 && tileWouldCauseChainViolation(index, 1)) {
                        tile.classList.add('chain-violation');
                    } else if (gameState.currentPlayer === 1) {
                        // Enhanced mobile touch support
                        addMobileTouchSupport(tile, () => selectTile(1, index, value));
                        // Keep drag functionality for desktop browsers
                        tile.draggable = true;
                        tile.ondragstart = (e) => handleDragStart(e, 1, index, value);
                        tile.ondragend = handleDragEnd;
                        
                        // Check if selected
                        if (gameState.selectedTile?.player === 1 && gameState.selectedTile?.index === index) {
                            tile.classList.add('selected');
                        }
                    }
                }
                
                player1Container.appendChild(tile);
            });
            
            // Player 2 tiles
            gameState.player2Tiles.forEach((value, index) => {
                const tile = document.createElement('div');
                tile.className = 'tile';
                tile.textContent = value;
                tile.setAttribute('data-player', '2');
                tile.setAttribute('data-index', index);
                tile.setAttribute('data-value', value);
                
                if (gameState.player2Used.has(index)) {
                    tile.classList.add('used');
                } else {
                    // Check for chain violations
                    if (!gameState.isAnalysisMode && gameState.currentPlayer === 2 && tileWouldCauseChainViolation(index, 2)) {
                        tile.classList.add('chain-violation');
                    } else if (gameState.isAnalysisMode || gameState.currentPlayer === 2) {
                        // Enhanced mobile touch support
                        addMobileTouchSupport(tile, () => selectTile(2, index, value));
                        // Keep drag functionality for desktop browsers
                        tile.draggable = true;
                        tile.ondragstart = (e) => handleDragStart(e, 2, index, value);
                        tile.ondragend = handleDragEnd;
                        
                        // Check if selected
                        if (gameState.selectedTile?.player === 2 && gameState.selectedTile?.index === index) {
                            tile.classList.add('selected');
                        }
                    }
                }
                
                player2Container.appendChild(tile);
            });
        }

        // Enhanced mobile touch support
        function addMobileTouchSupport(element, callback) {
            // Standard click event
            element.onclick = callback;
            
            // Enhanced touch support for mobile
            let touchStartTime = 0;
            let touchMoved = false;
            
            element.ontouchstart = function(e) {
                touchStartTime = Date.now();
                touchMoved = false;
                // Add visual feedback
                this.style.transform = 'scale(0.95)';
                this.style.opacity = '0.8';
            };
            
            element.ontouchmove = function(e) {
                touchMoved = true;
                // Prevent scrolling when dragging game elements
                e.preventDefault();
            };
            
            element.ontouchend = function(e) {
                // Remove visual feedback
                this.style.transform = '';
                this.style.opacity = '';
                
                const touchDuration = Date.now() - touchStartTime;
                if (!touchMoved && touchDuration < 500) {
                    // This was a tap, not a drag
                    e.preventDefault();
                    callback(e);
                }
            };
        }

        // Handle drag start
        function handleDragStart(e, player, index, value) {
            if (player !== gameState.currentPlayer || gameState.gameEnded) {
                e.preventDefault();
                return;
            }
            
            // Set selected tile
            gameState.selectedTile = { player, index, value };
            
            // Store drag data
            e.dataTransfer.setData('text/plain', JSON.stringify({
                player: player,
                index: index,
                value: value
            }));
            
            // Visual feedback
            e.target.style.opacity = '0.5';
            
            drawPlayerTiles();
            drawBoard();
        }

        // Handle drag end
        function handleDragEnd(e) {
            e.target.style.opacity = '';
        }

        // Handle hex click (tap to place if tile selected)
        function handleHexClick(hexId) {
            if (gameState.gameEnded) return;
            
            if (gameState.selectedTile) {
                // Place tile if one is selected
                placeTile(hexId);
            } else {
                // Show feedback that no tile is selected
                showMessage('Select a tile first!', 'info', 2000);
            }
        }

        // Handle clicks on invalid hexes with specific feedback
        function handleInvalidHexClick(hexId, invalidType) {
            if (gameState.gameEnded) return;
            
            if (!gameState.selectedTile) {
                showMessage('Select a tile first!', 'info', 2000);
                return;
            }
            
            // Check if position is occupied first
            if (gameState.board[hexId] !== null) {
                showMessage('Position already occupied!', 'error');
                return;
            }
            
            // Show specific error based on invalid type
            if (invalidType === 'chain') {
                showMessage('Invalid move! Chain Length Violation', 'error');
            } else if (invalidType === 'adjacent') {
                showMessage('Invalid move! Must be adjacent to existing tiles.', 'error');
            } else if (invalidType === 'not-adjacent') {
                showMessage('Invalid move! Must be adjacent to existing tiles.', 'error');
            }
        }

        // Handle drop on hexagon
        function handleDrop(e, hexId) {
            e.preventDefault();
            
            if (gameState.gameEnded) return;
            
            try {
                const dragData = JSON.parse(e.dataTransfer.getData('text/plain'));
                
                // Verify it's the current player's turn
                if (dragData.player !== gameState.currentPlayer) return;
                
                // Set the selected tile from drag data
                gameState.selectedTile = {
                    player: dragData.player,
                    index: dragData.index,
                    value: dragData.value
                };
                
                // Place the tile
                placeTile(hexId);
                
            } catch (error) {
                console.error('Error handling drop:', error);
            }
        }

        // Select a tile
        function selectTile(player, index, value) {
            if (player !== gameState.currentPlayer) return;
            if (gameState.gameEnded) return;
            
            gameState.selectedTile = { player, index, value };
            showMessage(`Tile ${value} selected. Tap a green hex to place it.`, 'info', 2500);
            drawPlayerTiles();
            drawBoard();
        }

        // Place a tile on the board
        function placeTile(hexIndex) {
            if (gameState.gameEnded) {
                showMessage('Game has ended!', 'error');
                return;
            }
            
            if (!gameState.selectedTile) {
                showMessage('Select a tile first!', 'info');
                return;
            }
            
            if (gameState.board[hexIndex] !== null) {
                showMessage('Position already occupied!', 'error');
                return;
            }
            
            const validMoves = getValidMoves();
            if (!validMoves.includes(hexIndex)) {
                // Check what type of invalid move this is
                const adjacentHexes = getAdjacentHexes(hexIndex);
                const hasAdjacentOccupied = adjacentHexes.some(id => 
                    gameState.board[id] !== null
                );
                
                if (!hasAdjacentOccupied) {
                    showMessage('Invalid move! Must be adjacent to existing tiles.', 'error');
                } else if (!checkChainLengthConstraint(hexIndex)) {
                    showMessage('Invalid move! Chain Length Violation', 'error');
                } else {
                    showMessage('Invalid move!', 'error');
                }
                return;
            }
            
            const tileValue = gameState.selectedTile.value;
            
            // Place the tile
            gameState.board[hexIndex] = {
                value: gameState.selectedTile.value,
                player: gameState.currentPlayer
            };
            
            // Track last placed tile for animation
            gameState.lastPlacedTile = hexIndex;
            
            // Mark tile as used
            if (gameState.currentPlayer === 1) {
                gameState.player1Used.add(gameState.selectedTile.index);
            } else {
                gameState.player2Used.add(gameState.selectedTile.index);
            }
            
            // Add to move history
            gameState.moveHistory.push({
                hexId: hexIndex,
                value: gameState.selectedTile.value,
                player: gameState.currentPlayer,
                tileIndex: gameState.selectedTile.index
            });
            
            // Show success message
            showMessage(`Player ${gameState.currentPlayer} placed tile ${tileValue}!`, 'success', 2000);
            
            // Check for game end
            if (gameState.board.every(cell => cell !== null)) {
                gameState.gameEnded = true;
                endGame();
            } else {
                // Switch players
                gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
                gameState.selectedTile = null;
                
                // Update turn indicator
                const indicator = document.getElementById('turnIndicator');
                indicator.textContent = `Player ${gameState.currentPlayer}'s Turn`;
                indicator.className = `turn-indicator player${gameState.currentPlayer}`;
            }
            
            // Update everything
            updateScores();
            drawPlayerTiles();
            drawBoard();
            updateButtonStates();
            
            // Animate chain lines for the placed tile
            setTimeout(() => {
                animateChainLines(hexIndex);
            }, 200); // Slight delay after tile placement
            
            // Clear last placed tile after animation completes
            setTimeout(() => {
                gameState.lastPlacedTile = null;
            }, 400);
        }

        // End game
        function endGame() {
            const scores = calculateScores();
            const indicator = document.getElementById('turnIndicator');
            
            if (scores.player1 > scores.player2) {
                const pointDiff = scores.player1 - scores.player2;
                indicator.textContent = `GAME OVER - Player 1 Wins!`;
                indicator.className = 'turn-indicator player1';
                showMessage(`🎉 Player 1 Wins by ${pointDiff} Points! 🎉`, 'success', 5000);
            } else if (scores.player2 > scores.player1) {
                const pointDiff = scores.player2 - scores.player1;
                indicator.textContent = `GAME OVER - Player 2 Wins!`;
                indicator.className = 'turn-indicator player2';
                showMessage(`🎉 Player 2 Wins by ${pointDiff} Points! 🎉`, 'success', 5000);
            } else {
                indicator.textContent = `GAME OVER - It's a Tie!`;
                indicator.className = 'turn-indicator';
                showMessage(`🤝 It's a Tie! Both players scored ${scores.player1} points!`, 'info', 5000);
            }
        }

        // Get hexagon points
        function getHexPoints(cx, cy, size) {
            const points = [];
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i;
                const x = cx + size * Math.cos(angle);
                const y = cy + size * Math.sin(angle);
                points.push(`${x},${y}`);
            }
            return points.join(' ');
        }

        // Draw the board
        function drawBoard() {
            const svg = document.getElementById('gameBoard');
            svg.innerHTML = '';
            
            const hexWidth = gameState.hexSize * 2;
            const hexHeight = Math.sqrt(3) * gameState.hexSize;
            
            // Board layout positions
            const positions = [
                {id: 0, x: gameState.centerX, y: gameState.centerY - hexHeight * 2},
                {id: 1, x: gameState.centerX - hexWidth * 0.75, y: gameState.centerY - hexHeight * 1.5},
                {id: 2, x: gameState.centerX + hexWidth * 0.75, y: gameState.centerY - hexHeight * 1.5},
                {id: 3, x: gameState.centerX - hexWidth * 1.5, y: gameState.centerY - hexHeight},
                {id: 4, x: gameState.centerX, y: gameState.centerY - hexHeight},
                {id: 5, x: gameState.centerX + hexWidth * 1.5, y: gameState.centerY - hexHeight},
                {id: 6, x: gameState.centerX - hexWidth * 0.75, y: gameState.centerY - hexHeight * 0.5},
                {id: 7, x: gameState.centerX + hexWidth * 0.75, y: gameState.centerY - hexHeight * 0.5},
                {id: 8, x: gameState.centerX - hexWidth * 1.5, y: gameState.centerY},
                {id: 9, x: gameState.centerX, y: gameState.centerY},
                {id: 10, x: gameState.centerX + hexWidth * 1.5, y: gameState.centerY},
                {id: 11, x: gameState.centerX - hexWidth * 0.75, y: gameState.centerY + hexHeight * 0.5},
                {id: 12, x: gameState.centerX + hexWidth * 0.75, y: gameState.centerY + hexHeight * 0.5},
                {id: 13, x: gameState.centerX - hexWidth * 1.5, y: gameState.centerY + hexHeight},
                {id: 14, x: gameState.centerX, y: gameState.centerY + hexHeight},
                {id: 15, x: gameState.centerX + hexWidth * 1.5, y: gameState.centerY + hexHeight},
                {id: 16, x: gameState.centerX - hexWidth * 0.75, y: gameState.centerY + hexHeight * 1.5},
                {id: 17, x: gameState.centerX + hexWidth * 0.75, y: gameState.centerY + hexHeight * 1.5},
                {id: 18, x: gameState.centerX, y: gameState.centerY + hexHeight * 2}
            ];
            
            const validMoves = getValidMoves();
            
            // Get all adjacent empty cells
            const allAdjacentMoves = [];
            for (let i = 0; i < 19; i++) {
                if (gameState.board[i] === null) {
                    const adjacentHexes = getAdjacentHexes(i);
                    const hasAdjacentOccupied = adjacentHexes.some(id => 
                        gameState.board[id] !== null
                    );
                    if (hasAdjacentOccupied) {
                        allAdjacentMoves.push(i);
                    }
                }
            }
            
            // Draw each hexagon
            positions.forEach(pos => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                
                // Create hexagon
                const hex = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                hex.setAttribute('points', getHexPoints(pos.x, pos.y, gameState.hexSize));
                
                // Determine hex class based on state
                let hexClass = 'hex';
                const boardCell = gameState.board[pos.id];
                
                if (boardCell !== null) {
                    hexClass += ' occupied';
                } else if (validMoves.includes(pos.id)) {
                    hexClass += ' valid-move';
                    // Enhanced mobile touch support for hex clicks
                    addMobileTouchSupport(hex, () => handleHexClick(pos.id));
                    hex.ondragover = (e) => e.preventDefault();
                    hex.ondrop = (e) => handleDrop(e, pos.id);
                } else if (allAdjacentMoves.includes(pos.id)) {
                    // Check if chain violation
                    const isChainViolation = !checkChainLengthConstraint(pos.id);
                    if (isChainViolation) {
                        hexClass += ' chain-violation-hex';
                        addMobileTouchSupport(hex, () => handleInvalidHexClick(pos.id, 'chain'));
                    } else {
                        hexClass += ' invalid-move';
                        addMobileTouchSupport(hex, () => handleInvalidHexClick(pos.id, 'adjacent'));
                    }
                } else {
                    // Empty hex that's not adjacent
                    addMobileTouchSupport(hex, () => handleInvalidHexClick(pos.id, 'not-adjacent'));
                }
                
                hex.setAttribute('class', hexClass);
                hex.setAttribute('data-id', pos.id);
                
                g.appendChild(hex);
                
                // Add value text if cell is occupied
                if (boardCell !== null) {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', pos.x);
                    text.setAttribute('y', pos.y);
                    
                    // Determine if this tile should animate
                    let textClass = `hex-text player${boardCell.player || ''}`;
                    if (pos.id === gameState.lastPlacedTile) {
                        textClass += ` animate-in player${boardCell.player}`;
                    } else {
                        textClass += ' no-animation';
                    }
                    
                    text.setAttribute('class', textClass);
                    text.textContent = boardCell.value;
                    g.appendChild(text);
                }
                
                svg.appendChild(g);
            });
        }

        // Undo last move
        function undoMove() {
            if (gameState.moveHistory.length === 0) {
                showMessage('No moves to undo!', 'error', 2000);
                return;
            }
            
            const lastMove = gameState.moveHistory.pop();
            
            // Remove tile from board
            gameState.board[lastMove.hexId] = null;
            
            // Return tile to player's collection
            if (lastMove.player === 1) {
                gameState.player1Used.delete(lastMove.tileIndex);
            } else {
                gameState.player2Used.delete(lastMove.tileIndex);
            }
            
            // Switch back to previous player
            gameState.currentPlayer = lastMove.player;
            gameState.selectedTile = null;
            
            // Reset game ended state - game can continue after undo
            gameState.gameEnded = false;
            
            // Update turn indicator
            const indicator = document.getElementById('turnIndicator');
            indicator.textContent = `Player ${gameState.currentPlayer}'s Turn`;
            indicator.className = `turn-indicator player${gameState.currentPlayer}`;
            
            // Update everything
            updateScores();
            drawPlayerTiles();
            drawBoard();
            updateButtonStates();
            
            showMessage(`Move undone! Player ${gameState.currentPlayer}'s turn.`, 'success', 2000);
        }

        // Show reset confirmation modal
        function showResetConfirmation() {
            if (gameState.moveHistory.length === 0) {
                showMessage('Game already at starting position!', 'info', 2000);
                return;
            }
            
            const modal = document.getElementById('resetModal');
            modal.classList.add('show');
        }

        // Hide reset confirmation modal
        function hideResetConfirmation() {
            const modal = document.getElementById('resetModal');
            modal.classList.remove('show');
        }

        // Confirm and execute reset
        function confirmReset() {
            hideResetConfirmation();
            
            // Reset all game state
            gameState.currentPlayer = 1;
            gameState.selectedTile = null;
            gameState.board = Array(19).fill(null);
            gameState.board[9] = { value: 1, player: null }; // Center starts with 1
            gameState.player1Used.clear();
            gameState.player2Used.clear();
            gameState.moveHistory = [];
            gameState.gameEnded = false;
            
            // Update turn indicator
            const indicator = document.getElementById('turnIndicator');
            indicator.textContent = 'Player 1\'s Turn';
            indicator.className = 'turn-indicator player1';
            
            // Update everything
            updateScores();
            drawPlayerTiles();
            drawBoard();
            updateButtonStates();
            
            showMessage('Game reset! Player 1, select a tile to start.', 'info', 3000);
        }

        // Legacy reset function (kept for compatibility)
        function resetGame() {
            showResetConfirmation();
        }

        // Update button states
        function updateButtonStates() {
            const undoBtn = document.getElementById('undoBtn');
            const resetBtn = document.getElementById('resetBtn');
            const tileSetsBtn = document.getElementById('tileSetsBtn');
            
            // Undo button: disabled only if no moves
            undoBtn.disabled = gameState.moveHistory.length === 0;
            
            // Tile Sets button: disabled if moves have been made (board is not empty except for center "1")
            const boardEmpty = gameState.board.filter(cell => cell !== null).length <= 1;
            tileSetsBtn.disabled = !boardEmpty;
            if (!boardEmpty) {
                tileSetsBtn.style.opacity = '0.6';
                tileSetsBtn.style.cursor = 'not-allowed';
            } else {
                tileSetsBtn.style.opacity = '1';
                tileSetsBtn.style.cursor = 'pointer';
            }
            
            // Reset button: disabled if no moves made
            resetBtn.disabled = gameState.moveHistory.length === 0;
        }

        // Initialize game
        function initGame() {
            // Set center cell to 1
            gameState.board[9] = { value: 1, player: null };
            
            updateScores();
            drawPlayerTiles();
            drawBoard();
            updateButtonStates();
            
            // Show welcome message
            setTimeout(() => {
                showMessage('Welcome to HEXUKI! Player 1, select a tile to start.', 'info', 4000);
            }, 500);
        }

        // Show/hide rules modal
        function showRules() {
            const modal = document.getElementById('rulesModal');
            modal.classList.add('show');
        }

        function hideRules() {
            const modal = document.getElementById('rulesModal');
            modal.classList.remove('show');
        }

        // Show/hide tile sets modal
        function showTileSets() {
            // Check if board is empty (only center "1" allowed)
            const boardEmpty = gameState.board.filter(cell => cell !== null).length <= 1;
            if (!boardEmpty) {
                showMessage('Tile sets can only be changed when the board is empty!', 'error', 3000);
                return;
            }
            
            const modal = document.getElementById('tileSetsModal');
            const content = document.getElementById('tileSetsContent');
            
            // Generate tile set options
            content.innerHTML = '';
            Object.keys(tileSets).forEach(key => {
                const option = document.createElement('div');
                option.className = `tile-set-option ${gameState.currentTileSet === key ? 'active' : ''}`;
                option.onclick = () => selectTileSet(key);
                
                const name = document.createElement('div');
                name.className = 'tile-set-name';
                
                let displayName = key.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
                name.textContent = displayName;
                
                const tiles = document.createElement('div');
                tiles.className = 'tile-set-tiles';
                
                // Generate random sets if needed
                let displayTiles;
                if (key === 'random_same') {
                    tiles.textContent = `[?, ?, ?, ?, ?, ?, ?, ?, ?] (Same for both players)`;
                } else if (key === 'random_different') {
                    tiles.innerHTML = `P1: [?, ?, ?, ?, ?, ?, ?, ?, ?]<br>P2: [?, ?, ?, ?, ?, ?, ?, ?, ?]`;
                } else {
                    displayTiles = [...tileSets[key]].sort((a, b) => a - b);
                    tiles.textContent = `[${displayTiles.join(', ')}]`;
                }
                
                option.appendChild(name);
                option.appendChild(tiles);
                content.appendChild(option);
            });
            
            modal.classList.add('show');
        }

        function hideTileSets() {
            const modal = document.getElementById('tileSetsModal');
            modal.classList.remove('show');
        }

        function selectTileSet(setName) {
            if (gameState.moveHistory.length > 0) {
                showMessage('Cannot change tile set after moves have been made!', 'error');
                return;
            }
            
            gameState.currentTileSet = setName;
            
            // Handle random tile sets
            if (setName === 'random_same') {
                const randomSet = generateRandomTileSet().sort((a, b) => a - b);
                gameState.player1Tiles = [...randomSet];
                gameState.player2Tiles = [...randomSet];
            } else if (setName === 'random_different') {
                gameState.player1Tiles = generateRandomTileSet().sort((a, b) => a - b);
                gameState.player2Tiles = generateRandomTileSet().sort((a, b) => a - b);
            } else {
                gameState.player1Tiles = [...tileSets[setName]];
                gameState.player2Tiles = [...tileSets[setName]];
            }
            
            gameState.player1Used.clear();
            gameState.player2Used.clear();
            
            drawPlayerTiles();
            hideTileSets();
            
            let displayName = setName.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
            showMessage(`Tile set changed to: ${displayName}`, 'success');
        }

        // Toggle analysis mode
        function toggleAnalysisMode() {
            const btn = document.querySelector('.analysis-mode');
            
            if (gameState.isAnalysisMode) {
                // Exit analysis mode
                gameState.isAnalysisMode = false;
                btn.classList.remove('active');
                btn.textContent = 'Analysis';
                showMessage('Analysis mode disabled', 'info');
            } else {
                // Enter analysis mode
                gameState.isAnalysisMode = true;
                btn.classList.add('active');
                btn.textContent = 'Exit Analysis';
                showMessage('Analysis mode enabled - you can now place tiles for either player', 'info', 4000);
            }
            
            drawPlayerTiles();
        }

        // Initialize on load
        initGame();
    </script>
</body>
</html>